#!/usr/bin/env ruby
#
# craft
#
# Generate floating-point precision configurations for a target binary, and test
# them. Assemble a final recommended configuration. Based on "fpautoconf" and
# improved to be far more generic and robust.
#
# Mike Lam, UMD
# October 2012
#

# needed for opening stderr as well as stdin/stdout
# when spawning new system processes
require 'open3.rb'

# needed for object serialization
require 'yaml.rb'

# needed for file manipulation and directory removal
require 'fileutils.rb'


# {{{ top-level: global constants

$CRAFT_VERSION = "0.1 (beta)"                            # release version

$RESULT_PASS  = "Success!"                          # test result possibilities
$RESULT_FAIL  = "FAILED!"
$RESULT_ERROR = "ERROR!!!"

$TYPE_APPLICATION = "APPLICATION"                   # control point levels
$TYPE_MODULE      = "MODULE"
$TYPE_FUNCTION    = "FUNC"
$TYPE_BASICBLOCK  = "BBLK"
$TYPE_INSTRUCTION = "INSN"
$TYPE_SPACES = Hash.new("")
$TYPE_SPACES[$TYPE_APPLICATION] = ""                # for pretty output
$TYPE_SPACES[$TYPE_MODULE]      = "  "
$TYPE_SPACES[$TYPE_FUNCTION]    = "    "
$TYPE_SPACES[$TYPE_BASICBLOCK]  = "      "
$TYPE_SPACES[$TYPE_INSTRUCTION] = "        "
$TYPE_RANK = Hash.new(0)
$TYPE_RANK[$TYPE_APPLICATION] = 1
$TYPE_RANK[$TYPE_MODULE]      = 2
$TYPE_RANK[$TYPE_FUNCTION]    = 3
$TYPE_RANK[$TYPE_BASICBLOCK]  = 4
$TYPE_RANK[$TYPE_INSTRUCTION] = 5
$TYPE_RRANK = $TYPE_RANK.invert

$STATUS_NONE      = " "                             # replacement status posibilities
$STATUS_IGNORE    = "!"
$STATUS_SINGLE    = "s"
$STATUS_DOUBLE    = "d"
$STATUS_CANDIDATE = "?"
$STATUS_NULL      = "x"
$STATUS_CINST     = "i"
$STATUS_DCANCEL   = "c"
$STATUS_DNAN      = "n"
$STATUS_TRANGE    = "t"
$STATUS_RPREC     = "r"

$FPCONF_OPTS = Hash.new("")
$FPCONF_OPTS[$STATUS_SINGLE]  = "-c --svinp single"
$FPCONF_OPTS[$STATUS_DOUBLE]  = "-c --svinp double"
$FPCONF_OPTS[$STATUS_NULL]    = "-c --null"
$FPCONF_OPTS[$STATUS_CINST]   = "-c --cinst"
$FPCONF_OPTS[$STATUS_DCANCEL] = "-c --dcancel"
$FPCONF_OPTS[$STATUS_DNAN]    = "-c --dnan"
$FPCONF_OPTS[$STATUS_TRANGE]  = "-c --trange"
$FPCONF_OPTS[$STATUS_RPREC]   = "-c --rprec 52"

$FINALCFG_CUID = "FINAL"                            # special config; represents "best" final results

# }}}


# PPoint
#
# Represents a single control point in a program. There is a single APPLICATION
# PPoint at the root, and then it branches into modules, functions, etc. This
# keeps the entire program's structure in memory while only requiring a single
# copy (as older versions of this script did). The PPoint knows how to output
# actual configuration files (given a AppConfig object) that the mutator can use.
#
# {{{ PPoint
class PPoint
    attr_accessor :uid              # unique regex identifier; e.g. "INSN #34: 0x804d3f"
    attr_accessor :id               # program component identifier; e.g. 34 in line above
    attr_accessor :type             # module, function, instruction, etc.
    attr_accessor :orig_status      # single, double, ignore, candidate, none
    attr_accessor :parent           # PPoint
    attr_accessor :children         # array of PPoints
    attr_accessor :attrs            # string => string
    attr_accessor :byuid            # uid => PPoint          (for increased lookup speed)
    attr_accessor :byaddr           # addr => insn PPoint    (for increased lookup speed)

    def initialize (uid, type, orig_status)
        @uid = uid
        @id = 0
        if @uid =~ /#(\d+)/ then
            @id = $1.to_i
        end
        @type = type
        @orig_status = orig_status
        @parent = nil
        @children = Array.new
        @attrs = Hash.new
        @byuid = Hash.new
        @byaddr = Hash.new
    end

    def build_config_file (config, fn, only_insns=true)
        # write out a configuration file for this program and the given config
        # this method will only be called in an APPLICATION node; it calls
        # output() to recursively print the other levels
        fout = File.new(fn, "w")
        if @attrs.has_key?("prolog") then
            @attrs["prolog"].each_line do |line|
                if $mixed_use_rprec and only_insns then
                    if line =~ /^sv_inp/ then
                        if line.chomp == "sv_inp=yes" then
                            fout.puts "r_prec=yes"
                            fout.puts "r_prec_default_precision=52"
                        end
                    else
                        fout.puts line
                    end
                else
                    fout.puts line
                end
            end
        end
        if only_insns then
            output(config, fout, nil, nil)
        else
            output_all(config, fout)
        end
        fout.close
    end

    def build_lookup_hash(pt=nil)
        if pt.nil? then
            @byuid[@uid] = self
            @children.each do |child|
                build_lookup_hash(child)
            end
        else
            if pt.type == $TYPE_INSTRUCTION and pt.attrs.has_key?("addr") then
                @byaddr[pt.attrs["addr"]] = pt
            end
            @byuid[pt.uid] = pt
            pt.children.each do |child|
                build_lookup_hash(child)
            end
        end
    end

    def lookup_by_uid(uid)
        return @byuid[uid]
    end

    def lookup_by_addr(addr)
        return @byaddr[addr]
    end

    def build_cuid(tag = nil)
        cuid = @uid
        if not tag.nil? then
            cuid += " #{tag}"
        end
        return cuid
    end

    def build_label(tag = nil)
        # build human-readable label
        label = @uid
        if tag.nil? then
            tag = ""
        else
            tag += " "
        end
        if @uid.include?($TYPE_APPLICATION) then
            label = "APP #{tag}#{@attrs["desc"]}"
        elsif @uid.include?($TYPE_MODULE) then
            label = "MOD #{tag}#{@attrs["desc"]}"
        elsif @uid.include?($TYPE_FUNCTION) then
            label = "FUNC #{tag}#{@attrs["desc"]}"
        elsif @uid.include?($TYPE_BASICBLOCK) then
            label = "BBLK #{@attrs["addr"]} #{tag}"
        elsif @uid.include?($TYPE_INSTRUCTION) then
            label = "INSN #{@attrs["addr"]} #{tag}\"#{@attrs["desc"]}\""
        end
        return label.strip
    end

    def output_all(config, fout)
        prec_line = nil
        fout.print("^")
        if config.exceptions.has_key?(@uid) then
            # status overridden by current config
            fout.print(config.exceptions[@uid])
            if config.exceptions[@uid] == $STATUS_RPREC then
                prec_line = "#{type}_#{@id}_precision=#{config.precisions[@uid]}"
            end
        else
            if @orig_status == $STATUS_CANDIDATE then
                # candidate for replacement; output configuration default
                fout.print(config.default)
            else
                # no override; output original default
                fout.print(@orig_status)
            end
        end
        fout.print(" ")
        fout.print($TYPE_SPACES[@type])     # indentation
        fout.print(@uid)
        if @attrs.has_key?("desc") then
            fout.print(" \"")
            fout.print(@attrs["desc"])
            fout.print("\"")
        end
        fout.print("\n")
        if not prec_line.nil? then
            fout.puts prec_line
        end
        @children.each do |pt|
            pt.output_all(config, fout)
        end
    end

    def output(config, fout, overload, overload_prec)
        prec_line = nil
        fout.print("^")
        if type == $TYPE_INSTRUCTION then
            flag = @orig_status
            if @orig_status == $STATUS_CANDIDATE then
                # candidate for replacement; check to see if we should
                if not overload.nil? then
                    # status overridden by something higher up the tree
                    flag = overload
                    if overload == $STATUS_RPREC then
                        prec_line = "#{type}_#{@id}_precision=#{overload_prec}"
                    end
                else
                    if config.exceptions.has_key?(@uid) then
                        # status overridden by current config
                        flag = config.exceptions[@uid]
                        if config.exceptions[@uid] == $STATUS_RPREC then
                            prec_line = "#{type}_#{@id}_precision=#{config.precisions[@uid]}"
                        end
                    else
                        # no override; output configuration default
                        flag = config.default
                    end
                end
            end
            if $mixed_use_rprec then
                if flag == $STATUS_SINGLE then
                    flag = $STATUS_RPREC
                    prec_line = "#{type}_#{@id}_precision=#{$rprec_split_threshold}"
                elsif flag == $STATUS_DOUBLE then
                    flag = $STATUS_RPREC
                    prec_line = "#{type}_#{@id}_precision=52"
                end
            end
            fout.print(flag)
        else
            if overload.nil? then
                if config.exceptions.has_key?(@uid) then
                    # children status overridden by current config
                    overload = config.exceptions[@uid]
                    if overload == $STATUS_RPREC then
                        overload_prec = config.precisions[@uid]
                    end
                elsif not @orig_status == $STATUS_NONE then
                    # children status overridden by original config
                    overload = @orig_status
                end
            end
            fout.print(" ")
        end
        fout.print(" ")
        fout.print($TYPE_SPACES[@type])     # indentation
        fout.print(@uid)
        if @attrs.has_key?("desc") then
            fout.print(" \"")
            fout.print(@attrs["desc"])
            fout.print("\"")
        end
        fout.print("\n")
        if not prec_line.nil? then
            fout.puts prec_line
        end
        @children.each do |pt|
            pt.output(config, fout, overload, overload_prec)
        end
    end
end # }}}


# AppConfig
#
# Represents a particular replacement configuration. To save space, an
# exception-based scheme is used; it keeps a "default" replacement status for
# all instructions that are not covered by an exception. Any exceptions at a
# level higher than an instruction (module, function, etc.) propogate to
# lower levels.
#
# {{{ AppConfig
class AppConfig
    attr_accessor :cuid             # unique identifier (string)
    attr_accessor :label            # human-readable description; e.g. "MODULE #1: boxes.c; MODULE #2: spheres.c"
    attr_accessor :default          # status
    attr_accessor :exceptions       # cuid -> status
    attr_accessor :attrs            # string => string

    attr_accessor :defprec          # default precision (int)
    attr_accessor :precisions       # cuid -> int

    def initialize (cuid, label, default)
        @cuid = cuid
        @label = label
        @default = default
        @exceptions = Hash.new
        @attrs = Hash.new
        @defprec = 52
        @precisions = Hash.new
    end

    def <=> (c2)
        result = nil

        # ascending level rank -> descending executed %
        if @attrs.has_key?("level") and c2.attrs.has_key?("level") then
            l1 = @attrs["level"]
            l2 = c2.attrs["level"]
            if l1 == l2 then
                if @attrs.has_key?("pct_cinst") and c2.attrs.has_key?("pct_cinst") then
                    oc1 = @attrs["pct_cinst"].to_f
                    oc2 = c2.attrs["pct_cinst"].to_f
                    if oc1 == oc2 then
                        result = -1
                    else
                        result = oc2 <=> oc1
                    end
                else
                    result = -1
                end
            else
                result = $TYPE_RANK[l1] <=> $TYPE_RANK[l2]
            end
        else
            result = -1
        end

        # descending instrumented % + executed %
        if @attrs.has_key?("pct_icount") and c2.attrs.has_key?("pct_icount") and
           @attrs.has_key?("pct_cinst") and c2.attrs.has_key?("pct_cinst") then
            oi1 = @attrs["pct_icount"].to_f
            oi2 = c2.attrs["pct_icount"].to_f
            oc1 = @attrs["pct_cinst"].to_f
            oc2 = c2.attrs["pct_cinst"].to_f
            result = (oi2+oc2) <=> (oi1+oc1)
        end

        return result
    end

    def filename
        # add sanitized cuid for uniqueness
        fn = "#{$search_tag}_"
        @cuid.each_char do |c|
            if c =~ /[0-9a-zA-Z_]/ then
                fn << c.downcase
            elsif c == ' ' then
                fn << "_"
            end
        end
        # add sanitized description for readability (in some cases)
        if @attrs.has_key?("desc") and (@cuid.include?($TYPE_MODULE) or @cuid.include?($TYPE_FUNCTION)) then
            @attrs["desc"].each_char do |c|
                if c =~ /[0-9a-zA-Z_]/ then
                    fn << c.downcase
                elsif c == ' ' then
                    fn << "_"
                end
            end
        end
        fn << ".cfg"
        return fn
    end

    def add_pt_info(pt)
        if pt.attrs.has_key?("cinst") then
            @attrs["cinst"] = pt.attrs["cinst"]
        else
            @attrs["cinst"] = 0
        end
    end

end # }}}


# Strategy
#
# Provides rules and procedures governing the search process. This class is
# intended to be inherited and overloaded; this particular implementation does a
# very simple, naive, breadth-first search through the application. It also has
# two simple optimizations:
#
#   1) Ignore program control branches that do not contain any FP instructions
#   2) Ignore program control branches that only have a single child (just do
#      that one instead)
#
# {{{ Strategy
class Strategy
    attr_accessor :program
    attr_accessor :preferred
    attr_accessor :alternate
    attr_accessor :base_type

    def initialize(program, pref, alt)
        @preferred = pref
        @alternate = alt
        @program = program
        update_icount(@program)
    end

    def has_custom_supervisor?
        return false
    end

    def update_icount(point)
        # allow us to ignore branches of the program that don't actually contain
        # any FP instructions
        total = 0
        point.children.each do |child|
            update_icount(child)
            total += child.attrs["icount"].to_i
        end
        if point.type == $TYPE_INSTRUCTION and point.orig_status == $STATUS_CANDIDATE then
            total += 1
        end
        point.attrs["icount"] = total.to_s
    end

    def build_initial_configs
        # try to replace the entire program
        configs = Array.new
        cfg = AppConfig.new(@program.build_cuid, @program.build_label, @alternate)
        cfg.add_pt_info(@program)
        cfg.exceptions[@program.uid] = @preferred
        cfg.attrs["level"] = $TYPE_APPLICATION
        configs << cfg
        return configs
    end

    def split_config(config)
        # add a config for each child node of each exception
        configs = Array.new
        config.exceptions.each_pair do |k,v|
            pt = @program.lookup_by_uid(k)
            pt.children.each do |child|

                # skip nodes with no FP instructions
                if child.attrs["icount"].to_i > 0 then
                    child_pt = child

                    # skip single-child nodes
                    if child.children.size == 1 then
                        child_pt = child.children.first
                    end

                    cfg = AppConfig.new(child_pt.build_cuid, child_pt.build_label, config.default)
                    cfg.add_pt_info(pt)
                    cfg.exceptions[child_pt.uid] = v
                    cfg.attrs["level"] = child_pt.type
                    configs << cfg
                end
            end
        end
        return configs
    end

    def build_final_config(results)
        # simple union of all passing configs
        cfg = AppConfig.new($FINALCFG_CUID, "Final Configuration", @alternate)
        results.each do |r|
            if r.attrs.has_key?("result") and r.attrs["result"] == $RESULT_PASS then
                r.exceptions.each_pair do |k,v|
                    if cfg.exceptions.has_key?(k) and not (cfg.exceptions[k] == v) then
                        puts "WARNING: Conflicting results for #{cfg.cuid}: #{cfg.exceptions[k]} and #{v}"
                    end
                    cfg.exceptions[k] = v
                end
            end
        end
        return cfg
    end
end # }}}


# BinaryStrategy
#
# Improved search algorithm that performs a binary search on failed configs
# rather than immediately adding all subchild configs to the queue. It also
# prioritizes new configs using the profiling results.
#
# {{{ BinaryStrategy
class BinaryStrategy < Strategy

    def split_config(config)
        configs = Array.new

        # build list of new configurations
        if config.exceptions.size > 1 then

            # last config tried multiple exceptions;
            # add a config for each exception and try again
            config.exceptions.each_pair do |k,v|
                pt = @program.lookup_by_uid(k)
                cfg = AppConfig.new(pt.build_cuid, pt.build_label, config.default)
                cfg.add_pt_info(pt)
                cfg.exceptions[pt.uid] = v
                cfg.attrs["level"] = pt.type
                configs << cfg
            end
        else

            # add a config for each child node of the current exception
            config.exceptions.each_pair do |k,v|
                pt = @program.lookup_by_uid(k)
                pt.children.each do |child|

                    # skip nodes with no FP instructions
                    # stop at basic blocks if that's desired
                    if child.attrs["icount"].to_i > 0 then
                        child_pt = child

                        # skip single-child nodes
                        if child.children.size == 1 and child.type != @base_type then
                            child_pt = child.children.first
                        end

                        cfg = AppConfig.new(child_pt.build_cuid, child_pt.build_label, config.default)
                        cfg.add_pt_info(child_pt)
                        #puts "ADDING #{cfg.cuid} #{child_pt.type}"
                        cfg.exceptions[child_pt.uid] = v
                        cfg.attrs["level"] = child_pt.type
                        configs << cfg
                    end
                end
            end
        end

        # sort in descending order of instruction executions
        configs.sort! { |c1, c2| c2.attrs["cinst"].to_i <=> c1.attrs["cinst"].to_i }

        # merge into two (binary search) if we have a lot of new configs
        if configs.size > 5 then
            pivot = configs.size / 2
            left_cfg  = AppConfig.new(config.cuid + " LEFT",  config.label + " LEFT",  config.default)
            right_cfg = AppConfig.new(config.cuid + " RIGHT", config.label + " RIGHT", config.default)
            left_cfg.attrs["cinst"]  = "0"
            right_cfg.attrs["cinst"] = "0"
            configs.each do |cfg|
                cfg.exceptions.each_pair do |k,v|
                    if pivot > 0 then
                        left_cfg.exceptions[k] = v
                        if cfg.attrs.has_key?("cinst") then
                            left_cfg.attrs["cinst"] = (left_cfg.attrs["cinst"].to_i + cfg.attrs["cinst"].to_i).to_s
                        end
                    else
                        right_cfg.exceptions[k] = v
                        if cfg.attrs.has_key?("cinst") then
                            right_cfg.attrs["cinst"] = (right_cfg.attrs["cinst"].to_i + cfg.attrs["cinst"].to_i).to_s
                        end
                    end
                end
                pivot -= 1
            end
            left_cfg.attrs["level"]  = config.attrs["level"]
            right_cfg.attrs["level"] = config.attrs["level"]
            configs = Array.new
            configs << left_cfg
            configs << right_cfg
        end
        return configs
    end
end # }}}


# DeltaDebugStrategy
#
# Implements a lower-cost delta-debugging strategy as described in
# Rubio-Gonzalez et al. [SC'13].
#
class DeltaDebugStrategy < Strategy

    def has_custom_supervisor?
        return true
    end

    def get_cost(cfg)
        if cfg.attrs.has_key?("cinst") and cfg.attrs["cinst"].to_i != 0 then
            return 1.0 / cfg.attrs["cinst"].to_f
        else
            return 1.0
        end
    end

    def run_custom_supervisor
        
        # get set of all possible basetype-level changes
        root = AppConfig.new("ALL", "ALL", @alternate)
        find_configs(@program, root)

        # number of divisions at current level
        div = 2

        # lowest-cost (most replacements) config found so far
        @lc_cfg = root
        @lc_cfg.attrs["cinst"] = 0

        done = false
        while not done do

            puts "Current LC: #{@lc_cfg.exceptions.size} change(s), #{@lc_cfg.attrs["cinst"]} execution(s), cost=#{get_cost(@lc_cfg)}"

            # partition current 
            
            lc_div = div
            divs = @lc_cfg.exceptions.each_slice([1,(@lc_cfg.exceptions.size.to_f/div.to_f).ceil.to_i].max).to_a
            set_cuids = []
            com_cuids = []
            divs.size.times do |i|

                puts "Test #{i+1}/#{divs.size} in round of #{div}"

                # build test subset
                setuid = @lc_cfg.cuid + " S_#{i+1}_#{div}"
                set = AppConfig.new(setuid, setuid, @lc_cfg.default)
                set.attrs["cinst"] = 0
                divs[i].each do |k,v|
                    set.exceptions[k] = v
                    set.attrs["cinst"] += @program.lookup_by_uid(k).attrs["cinst"].to_i
                end
                puts "SET: #{set.exceptions.size} change(s), #{set.attrs["cinst"]} execution(s)"
                add_to_workqueue(set)
                set_cuids << setuid

                # build and test complement set
                comuid = @lc_cfg.cuid + " C_#{i+1}_#{div}"
                com = AppConfig.new(comuid, comuid, @lc_cfg.default)
                com.attrs["cinst"] = 0
                divs.size.times do |j|
                    if i != j then
                        divs[j].each do |k,v|
                            com.exceptions[k] = v
                            com.attrs["cinst"] += @program.lookup_by_uid(k).attrs["cinst"].to_i
                        end
                    end
                end
                puts "COMPLEMENT: #{com.exceptions.size} change(s), #{com.attrs["cinst"]} execution(s)"
                add_to_workqueue(com)
                com_cuids << comuid

            end
            puts "ADDED #{set_cuids.size + com_cuids.size} configs to queue"

            # wait until all the previously-added configs are finished
            run_main_supervisor_loop

            # look through the tested configurations and update LC if
            # appropriate
            changed = false
            configs = get_tested_configs
            configs.each do |cfg|
                #puts "EVALUATING: #{cfg.inspect}  cost=#{get_cost(cfg)}"
                if set_cuids.include?(cfg.cuid) and cfg.attrs["result"] == $RESULT_PASS and
                        get_cost(cfg) < get_cost(@lc_cfg) then
                    @lc_cfg = cfg
                    lc_div = 2
                    changed = true
                    puts "LC REPLACED by #{cfg.cuid}!  cost=#{get_cost(cfg)}"
                end
                if com_cuids.include?(cfg.cuid) and cfg.attrs["result"] == $RESULT_PASS and
                        get_cost(cfg) < get_cost(@lc_cfg) then
                    @lc_cfg = cfg
                    lc_div = div-1
                    changed = true
                    puts "LC REPLACED by #{cfg.cuid}!  cost=#{get_cost(cfg)}"
                end
            end

            # set up next iteration (if not done)
            if changed then
                #puts "FOUND NEW LC: #{@lc_cfg.inspect}  cost=#{get_cost(@lc_cfg)}"
                div = lc_div
            else
                print "NO NEW LC - "
                if div > @lc_cfg.exceptions.size then
                    puts "DONE!"
                    done = true
                else
                    puts "moving to next round (round of #{2*div})"
                    div = 2 * div
                end
            end

            puts ""
        end
    end

    def build_final_config(results)
        final_cfg = AppConfig.new("FINAL", "FINAL", @alternate)
        final_cfg.attrs["cinst"] = 0
        results.each do |r|
            if not @lc_cfg.nil? and r.cuid == @lc_cfg.cuid then
                return r
            end
            if r.attrs.has_key?("result") and r.attrs["result"] == $RESULT_PASS then
                if final_cfg.nil? or get_cost(r) < get_cost(final_cfg) then
                    final_cfg = r
                end
            end
        end
        return final_cfg
    end

    def build_initial_configs
        return []
    end

    def find_configs(pt, cfg)
        if pt.type == @base_type then
            cfg.add_pt_info(pt)
            cfg.exceptions[pt.uid] = @preferred
        else
            pt.children.each do |child|
                find_configs(child, cfg)
            end
        end
    end

    def split_config(config)
        return []
    end
end

# ExhaustiveStrategy
#
# Naive search algorithm that searches all instructions immediately. Highly
# parallelizable but generally less effecient than binary searching. Potentially
# useful for pointing out inconsistencies in binary search results.
#
# {{{ ExhaustiveStrategy
class ExhaustiveStrategy < Strategy

    def build_initial_configs
        # find all base_type-level points
        configs = Array.new
        find_configs(@program, configs)
        return configs
    end

    def find_configs(pt, configs)
        if pt.type == @base_type then
            cfg = AppConfig.new(pt.build_cuid, pt.build_label, @alternate)
            cfg.add_pt_info(pt)
            cfg.exceptions[pt.uid] = @preferred
            cfg.attrs["level"] = pt.type
            configs << cfg
        else
            pt.children.each do |child|
                find_configs(child, configs)
            end
        end
    end

    def split_config(config)
        # don't split
        return Array.new
    end

end # }}}


# RPrecStrategy
#
# Search algorithm that find the lowest reduced-precision level for each
# instruction that allows the entire program to pass verification. Performs a
# binary search on the precision level to speed convergence.
#
# {{{ RPrecStrategy
class RPrecStrategy < Strategy

    attr_accessor :lower_bound
    attr_accessor :upper_bound
    attr_accessor :num_iterations
    attr_accessor :split_threshold
    attr_accessor :runtime_pct_threshold
    attr_accessor :skip_app_level

    def initialize(program, pref, alt)
        super(program, pref, alt)
        @lower_bound = Hash.new(-1)
        @upper_bound = Hash.new(52)
        @num_iterations = Hash.new(52)
        @split_threshold = 23               # single-precision by default
        @runtime_pct_threshold = 0.0        # disabled by default
        @skip_app_level = false             # don't skip app level by default
    end

    def reload_bounds_from_results(results)
        @lower_bound = Hash.new(-1)
        @upper_bound = Hash.new(52)
        @num_iterations = Hash.new(0)
        results.each do |cfg|
            cfg.precisions.each_pair do |uid, prec|
                #puts "adjusting #{uid} for result #{cfg.attrs["result"]} at #{prec}"
                if cfg.attrs["result"] == $RESULT_PASS then
                    @upper_bound[uid] = [@upper_bound[uid],prec].min
                else
                    @lower_bound[uid] = [@lower_bound[uid],prec].max
                end
                @num_iterations[uid] = @num_iterations[uid] + 1
            end
        end
    end

    def build_initial_configs
        configs = Array.new
        if @skip_app_level then
            # start at the module level
            @program.children.each do |child|
                child_pt = child

                # skip single-child nodes
                if child.children.size == 1 and child.type != @base_type then
                    child_pt = child.children.first
                end

                add_midpoint_cfg(child_pt, configs)
            end
        else
            # start at the app level
            add_midpoint_cfg(@program, configs)
        end
        return configs
    end

    def add_midpoint_cfg(pt, configs)
        mid = (@upper_bound[pt.uid] - @lower_bound[pt.uid])/2 + @lower_bound[pt.uid]
        #puts "  new mid to test at pt #{pt.uid}: #{mid} in (#{@lower_bound[pt.uid]}, #{@upper_bound[pt.uid]}] cinst=#{pt.attrs["cinst"]}"
        if (pt.attrs["icount"].to_i > 0 and 
                @upper_bound[pt.uid] > @lower_bound[pt.uid]+1) and
                (mid != @upper_bound[pt.uid]) and (mid != @lower_bound[pt.uid]) then
            tag = ("%02d-bit" % mid)
            cfg = AppConfig.new(pt.build_cuid(tag), pt.build_label(tag), @alternate)
            cfg.add_pt_info(pt)
            cfg.exceptions[pt.uid] = @preferred
            cfg.precisions[pt.uid] = mid
            cfg.attrs["level"] = pt.type
            cfg.attrs["prec"] = mid

            if @runtime_pct_threshold > 0.0 then
                # skip nodes with less than X% of total executions
                calculate_pct_stats(cfg)
                if cfg.attrs["pct_cinst"].to_f > @runtime_pct_threshold then
                    configs << cfg
                end
            else
                configs << cfg
            end
        end
    end

    def split_config(cfg)
        configs = Array.new

        max_upper_bound = 0

        # add new midpoint configs
        cfg.exceptions.each_key do |k|
            pt = @program.lookup_by_uid(k)
            max_upper_bound = [max_upper_bound, @upper_bound[pt.uid]].max
            add_midpoint_cfg(pt, configs)
        end

        # descend if done with this level and above precision-level threshold
        if configs.size == 0 and max_upper_bound > @split_threshold then

            cfg.exceptions.each_pair do |k,v|
                pt = @program.lookup_by_uid(k)
                pt.children.each do |child|

                    # skip nodes with no FP instructions
                    if child.attrs["icount"].to_i > 0 then

                        child_pt = child

                        # skip single-child nodes
                        if child.children.size == 1 and child.type != @base_type then
                            child_pt = child.children.first
                        end

                        add_midpoint_cfg(child_pt, configs)
                    end
                end
            end
        end

        return configs
    end

    def build_final_config(results)
        reload_bounds_from_results(results)
        # simple union of all passing configs
        cfg = AppConfig.new($FINALCFG_CUID, "Final Configuration", @alternate)
        @upper_bound.each_pair do |uid, prec|
            cfg.exceptions[uid] = $STATUS_RPREC
            cfg.precisions[uid] = prec
        end
        return cfg
    end

end
# }}}


# App entry point

# {{{ main method
def main
    srand

    # initialize global variables
    $search_tag = "craft"                   # filename tag
    $craft_driver = "craft_driver"          # standard driver program name
    $status_preferred = $STATUS_SINGLE      # preferred replacement status
    $status_alternate = $STATUS_DOUBLE      # replacement status if cannot be preferred
    $status_blank = " "                     # "no result" replacement status
    $fortran_mode = false                   # pass "-N" to mutator
    $base_type = $TYPE_INSTRUCTION          # stop splitting configs at this level
    $skip_nonexecuted = true                # don't bother running configs with non-executed instructions
    $mixed_use_rprec = false                # use rprec 23-bit truncation to simulate mixed svinp analysis
    $rprec_split_threshold = 23             # config splitting threshold for reduced precision searches
    $rprec_runtime_pct_threshold = 0.0      # config cutoff runtime percentage threshold
    $rprec_skip_app_level = false           # skip the app level for rprec search
    $initial_cfg_fn = ""                    # initial config filename (may be blank)
    $prof_log_fn = ""                       # initial profiling log (may be blank)
    $cached_fn = ""                         # cached results from previous run (may be blank)
    $max_queue_length = 0                   # track largest queue size (approximate)
    $main_mode = "start"                    # main status ("start/search", "resume", "status", "clean", "worker", "help")
    $restart_inproc = false                 # resume by restarting all inprocess tests
    $resume_lower = false                   # resume at a lower level
    $num_workers = 1                        # number of worker threads
    $workers = Hash.new                     # worker proc info (pid => dirname)
    $status_buffer = ""                     # buffer for output (keeps multiprocess output clean)
    $strategy_name = "bin_simple"           # desired search strategy
    $self_invoke = File.basename($0)        # used to spawn worker threads
    $fpconf_invoke = "fpconf"               # invoke configuration generator
    $fpconf_options = "-c --svinp double"   # configuration generator options
    $fpinst_invoke = "fpinst"               # invoke mutator
    $cached_configs = Array.new             # cached results from a previous run
    $binary_serialization = true            # use binary serialization (faster) for queues instead of YAML
    $disable_queue_sort = false             # disable workqueue sorting
    $run_final_config = true                # test the final config?

    # check command-line options
    if ARGV.size == 0 or ARGV[0] == "help" or ARGV.include?("-h") then
        $main_mode = "help"
        print_usage
        exit
    end

    parse_command_line
    
    # cleaning mode
    if $main_mode == "clean" then
        puts "Cleaning..."
        clean_everything
        puts "Done."
        exit
    end

    # set up environment and filenames
    if $main_mode != "worker" then
        $search_path = Dir.getwd + "/"

        # this really should happen BEFORE parse_command_line so that the
        # command-line parameters will override the craft_driver options, but
        # the worker threads shouldn't read the craft_driver since the options
        # are saved in the settings files, but we don't know if we're a worker
        # until we parse the command-line options
        read_craft_driver
    end

    # plain text info files
    $settings_fn = "#{$search_path}#{$search_tag}.settings"
    $program_fn = "#{$search_path}#{$search_tag}.program"
    $mainlog_fn = "#{$search_path}#{$search_tag}.mainlog"
    $walltime_fn = "#{$search_path}#{$search_tag}.walltime"

    # files containing lists of AppConfig objects
    $workqueue_fn = "#{$search_path}#{$search_tag}.workqueue"     # waiting to be tested
    $inproc_fn = "#{$search_path}#{$search_tag}.inproc"           # currently running
    $tested_fn = "#{$search_path}#{$search_tag}.tested"           # finished (passed, failed, or aborted)

    # important single configuration files
    $orig_config_fn = "#{$search_path}craft_orig.cfg"
    $final_config_fn = "#{$search_path}craft_final.cfg"

    # configuration file directories
    $perf_path     = "#{$search_path}baseline/"    # baseline performance test
    $prof_path     = "#{$search_path}profile/"     # profiler run
    $final_path    = "#{$search_path}final/"       # single final "best" config (cfg file + mutant)
    $best_path     = "#{$search_path}best/"        # top 10 "best" individual configs (cfg files only)
    $passed_path   = "#{$search_path}passed/"      # all successful configs (cfg files only)
    $failed_path   = "#{$search_path}failed/"      # all failed configs (cfg files only)
    $aborted_path  = "#{$search_path}aborted/"     # all aborted configs (cfg files only)
    $snapshot_path = "#{$search_path}snapshots/"   # status printouts

    if $main_mode == "status" then
        print_status
        exit
    end

    # check for driver script
    if !File.exist?("#{$search_path}#{$craft_driver}") then
        puts "No driver program \"craft_driver\" found."
        puts "Aborting."
        exit
    end

    if $main_mode == "worker" then

        # this is just a worker process
        
        load_settings
        initialize_program
        read_profiler_data
        initialize_strategy
        run_main_search_loop                      # main loop
        #puts "Worker finished.  [Empty queue]"

    else

        # this is a supervisor process

        puts ""
        puts "CRAFT #{$CRAFT_VERSION}"
        puts "Executable:  #{$binary_name}"
        puts "Working dir: #{$search_path}"
        puts ""

        if $main_mode == "start" then
            # this is the first invocation of this analysis; initialize everything
            initialize_search
        else
            # we're resuming an analysis
            puts "Resuming in-process search ..."
            if File.exist?($final_path) then
                # clear out any final configuration testing
                FileUtils.rm_rf($final_path)
            end
            if File.exist?($walltime_fn) then
                # previous search was completed; restart wall timer
                $start_time = Time.now
                FileUtils.rm_rf($walltime_fn)
            end
            load_settings
            initialize_program
            read_profiler_data
            initialize_strategy
            if $restart_inproc then
                toDelete = Array.new
                Dir.glob("*_worker*") do |fn| toDelete << fn end
                toDelete.each do |f| FileUtils.rm_rf(f) end
                move_all_inproc_to_workqueue
            end
            if $resume_lower then
                resume_lower_search
                save_settings
            end
        end

        # set up worker thread folders
        $num_workers.times do |id|
            worker_dir = "#{$search_path + $binary_name}_#{Process.pid}_worker#{id}"
            if File.exist?(worker_dir) then
                FileUtils.rm_rf(worker_dir)
            end
            Dir.mkdir(worker_dir)
            $workers[id] = worker_dir
        end

        # spawn worker threads (don't spawn more than we need right now, though)
        [get_workqueue_length, $num_workers].min.times do |id|
            worker_dir = "#{$search_path + $binary_name}_#{Process.pid}_worker#{id}"
            job = fork do
                exec "cd #{worker_dir} && #{$self_invoke} worker #{id} #{$search_path}"
            end
            $workers.delete(id)
            $workers[job] = worker_dir
            #puts "Spawned worker thread #{id} (pid=#{job})."
        end

        # main loop
        puts "Initialization complete. Starting main search routine."
        puts ""
        if $strategy.has_custom_supervisor? then
            $strategy.run_custom_supervisor
        else
            run_main_supervisor_loop
        end

        # test final config, assemble results, etc.
        finalize_search

    end
end # }}}


# Search management routines

# {{{ initialize_search
def initialize_search
    # supervisor initialization
    
    $start_time = Time.now

    # create search config files
    File.new($settings_fn, "w").close
    File.new($workqueue_fn, "w").close
    File.new($inproc_fn, "w").close
    File.new($tested_fn, "w").close
    File.new($mainlog_fn, "w").close

    if $strategy_name == 'rprec' then
        puts "Initializing reduced-precision search. Options:"
        puts "  split_threshold=#{$rprec_split_threshold}"
        puts "  runtime_pct_threshold=#{$rprec_runtime_pct_threshold}"
        puts "  skip_app_level=#{$rprec_skip_app_level}"
    else
        puts "Initializing standard search:  strategy=#{$strategy_name}"
        puts "  mixed_use_rprec=#{$mixed_use_rprec}"
        if $mixed_use_rprec then
            puts "  split_threshold=#{$rprec_split_threshold}"
        end
    end

    # initial performance run
    print "Performing baseline performance test ... "
    $stdout.flush
    if !run_baseline_performance then
        puts "Baseline performance test failed verification!"
        puts "Aborting search."
        exit
    end
    puts "Done.  [Base error: #{$baseline_error}  walltime: #{format_time($baseline_runtime.to_f)}]"

    # generate initial configuration by calling fpconf
    # and initialize global data structures
    print "Generating initial configuration ... "
    $stdout.flush
    orig_cfg = File.open($orig_config_fn, "w")
    if $initial_cfg_fn.length > 0 && File.exists?($initial_cfg_fn) then
        # a base config was given; just read it
        print "(using base: #{$initial_cfg_fn}) "
        $stdout.flush
        IO.foreach($initial_cfg_fn) do |line|
            orig_cfg.puts line
        end
    else
        # run fpconf to generate config
        IO.popen("#{$fpconf_invoke} #{$fpconf_options} #{$binary_path}") do |io|
            io.each_line do |line|
                orig_cfg.puts line
            end
        end
    end
    Dir.glob("fpconf.log").each do |f| File.delete(f) end
    orig_cfg.close
    puts "Done."

    # read all program control points
    # depends on initial configuration being present
    initialize_program

    # initial profiling run
    # depends on $program being initialized
    print "Performing profiling test ... "
    $stdout.flush
    if not File.exist?($prof_path) and !run_profiler then
        puts "Baseline profiling test failed verification!"
        #puts "Aborting search."        # not really necessary; we can run
        #exit                           # without profiling data
    elsif File.exist?($prof_path) then
        files = Dir.glob("#{$prof_path}/*-c_inst*.log")
        if files.size > 0 then
            $prof_log_fn = files.first
        else
            puts "\nError: profile folder exists but there is no c_inst log file. Run \"craft clean\" and restart to generate it."
        end
        puts "Cached."
    else
        puts "Done."
    end
    read_profiler_data

    # initialize strategy object
    # depends on $program being initialized
    print "Initializing search strategy ... "
    initialize_strategy
    puts "Done.  [#{$total_candidates} candidates]"

    # save project settings to file (for workers to load)
    save_settings

    # initialize work queue
    configs = $strategy.build_initial_configs
    add_to_workqueue_bulk(configs)
    $max_queue_length = get_workqueue_length

    # create folders for saving configurations
    FileUtils.rm_rf($best_path)
    Dir.mkdir($best_path)
    FileUtils.rm_rf($passed_path)
    Dir.mkdir($passed_path)
    FileUtils.rm_rf($failed_path)
    Dir.mkdir($failed_path)
    FileUtils.rm_rf($aborted_path)
    Dir.mkdir($aborted_path)

end # }}}
# {{{ resume_lower_search
def resume_lower_search

    # figure out new base type
    old_base_type = $base_type
    new_base_rank = $TYPE_RANK[old_base_type]+1
    if !$TYPE_RRANK.has_key?(new_base_rank) then
        puts "Already at lowest base type."
    else
        puts "Lowering base type from #{$base_type} to #{$TYPE_RRANK[new_base_rank]}."
        $base_type = $TYPE_RRANK[new_base_rank]
        $strategy.base_type = $base_type
    end


    # look for new configurations
    configs = Array.new
    already_added = Hash.new(false)        # prevents adding identical cuids twice
    old_configs = get_tested_configs
    if $strategy_name == "rprec" then
        $strategy.reload_bounds_from_results(old_configs)
    end
    old_configs.each do |cfg|
        if is_single_base(cfg, old_base_type) and 
                (cfg.attrs["result"] != $RESULT_PASS or $strategy_name == "rprec") then
            $strategy.split_config(cfg).each do |c|
                if not already_added[c.cuid] then
                    configs << c
                    already_added[c.cuid] = true
                end
            end
        end
    end

    # initialize work queue
    add_to_workqueue_bulk(configs)
    $max_queue_length = get_workqueue_length

end # }}}
# {{{ run_main_search_loop
def run_main_search_loop
    cfg = get_next_workqueue_item

    # main search loop
    while !cfg.nil? do

        add_to_inproc(cfg)

        # queue status output
        queue_length = get_workqueue_length
        $status_buffer += "[Queue length: #{"%3d" % (queue_length+1)}]  "
        $max_queue_length = queue_length if queue_length > $max_queue_length

        # check list of already-tested configs
        cached = false
        load_cached_configs
        $cached_configs.each do |c|
            if c.cuid == cfg.cuid then

                # if we've already run this test, no need to run it again
                result = c.attrs["result"]
                puts "Using cached result for config #{cfg.label}: #{result}"
                cfg.attrs["cached"] = "yes"
                cfg.attrs["result"]  = c.attrs["result"]
                cfg.attrs["error"]   = c.attrs["error"]
                cfg.attrs["runtime"] = c.attrs["runtime"]
                cached = true
            end
        end

        # run the test and update queue
        if not cached then
            puts "Testing config #{cfg.label} ..."
            result = run_config(cfg)
        end
        add_tested_config(cfg)
        remove_from_inproc(cfg)
        rebuild_final_config

        add_children = true
        if $strategy_name == "rprec" then

            # always add children, but reload results first
            # so the strategy can make an informed decision
            $strategy.reload_bounds_from_results(get_tested_configs)

        elsif $strategy_name == "ddebug" then

            # supervisor thread handles splitting
            add_children = false

        else

            # check to see if we passed
            if result == $RESULT_PASS then
                add_children = false
            end

            # check to see if we're at the base type; stop if so
            if is_single_base(cfg, $base_type) then
                add_children = false
            end
        end

        # add any children we need to test
        if add_children then
            configs = $strategy.split_config(cfg)
            configs.each do |child|
                add_child = true

                # skip single-exception configs where the only exception
                # is lower than the base type; currently there is no
                # situation where we will encounter mixed-level configs
                if child.exceptions.keys.size == 1 then
                    pt = $program.lookup_by_uid(child.exceptions.keys.first)
                    if !pt.nil? and $TYPE_RANK[pt.type] > $TYPE_RANK[$base_type] then
                        add_child = false
                    end
                end

                # skip non-executed instructions if desired; assume they
                # will pass
                if $skip_nonexecuted and child.attrs["cinst"].to_i == 0 then
                    puts "Skipping non-executed config #{child.label}."
                    add_to_mainlog("    Skipping non-executed config #{child.label}.")
                    child.attrs["result"] = $RESULT_PASS
                    child.attrs["skipped"] = "yes"
                    if $strategy_name == "rprec" then
                        child.precisions.each_key do |k|
                            child.precisions[k] = 0
                        end
                    end
                    calculate_pct_stats(child)
                    add_tested_config(child)
                    rebuild_final_config
                    add_child = false
                end

                if add_child then
                    add_to_workqueue(child)
                    puts "Added config #{child.label} to workqueue."
                end
            end
        end

        cfg = get_next_workqueue_item
    end
end # }}}
#{{{ worker thread helper functions (can be used by custom supervisors)
def get_dead_workers
    #print "Checking for dead workers ... "
    dead_workers = Array.new
    $workers.each_pair do |job, dir|
        if job < $num_workers then
            # this job has never actually been started
            # (pid < $num_workers)
            dead_workers << [job, dir]
        else
            cmd = "ps -o s= p #{job.to_i}"
            stat = `#{cmd}`
            stat.chomp!
            if stat != "S" then
                dead_workers << [job, dir]
            end
        end
    end
    #puts "#{dead_workers.size} dead worker(s) found."
    return dead_workers
end
def restart_dead_workers(dead_workers)
    [get_workqueue_length, dead_workers.size].min.times do |i|
        job,dir = dead_workers.pop
        $workers.delete(job)
        id = File.basename(dir)
        if id =~ /worker(\d+)/ then
            id = $1
        else
            id = id[$binary_name.length+1,id.length-$binary_name.length-1]
        end
        FileUtils.rm_rf(dir)
        Dir.mkdir(dir)
        job = fork do
            exec "cd #{dir} && #{$self_invoke} worker #{id} #{$search_path}"
        end
        #puts "Respawned worker thread #{id} (pid=#{job})."
        $workers[job] = dir
    end
end
def wait_for_workers
    $workers.each_pair do |job, dir|
        begin
            Process.wait(job.to_i)
        rescue
        end
        FileUtils.rm_rf(dir)
    end
end
# }}}
# {{{ run_main_supervisor_loop
def run_main_supervisor_loop

    # keep going until there are no more configs to test
    while get_workqueue_length > 0 or get_inproc_length > 0 do

        keep_running = true
        while keep_running do

            $max_queue_length = get_workqueue_length if get_workqueue_length > $max_queue_length

            # check for dead worker processes
            dead_workers = get_dead_workers

            if dead_workers.size == $num_workers and get_workqueue_length == 0 then

                # everyone's done and there's nothing else in the queue
                keep_running = false

            elsif get_workqueue_length > 0 then

                # there's still stuff to do; restart dead workers
                restart_dead_workers(dead_workers)

            end

            # wait a while
            sleep 5
        end

        # clean up any workers and directories
        wait_for_workers

        # if the workqueue is empty and all the workers are dead but there
        # are still configs in the inproc queue, then something was aborted;
        # move any unfinished configs back to the workqueue and restart
        if get_inproc_length > 0 then
            puts "Unfinished jobs; restarting workers ..."
            move_all_inproc_to_workqueue
        end
    end
end # }}}
# {{{ finalize_search
def finalize_search

    if File.exist?($final_path) then
        # another process is already finalizing
        puts "Finalization already underway."
        return
    else
        Dir.mkdir($final_path)
    end

    # queue status output
    puts ""
    puts "Candidate queue exhausted.  [Max queue length: ~#{$max_queue_length} item(s)]"

    # generate final config file
    print "Generating final configuration ... "
    $stdout.flush
    rebuild_final_config
    FileUtils.cp($final_config_fn, $final_path)
    puts "Done."

    # try the final config (and keep results)
    puts "Testing final configuration ... "
    Dir.chdir($final_path)
    if $run_final_config then
        run_config_file($final_config_fn, true, $final_config.label)
    end
    Dir.chdir($search_path)

    # start generating final report
    report = build_best_report(10, true)

    # finalize report
    elapsed = Time.now.to_f - $start_time.to_f
    summary = get_tested_configs_summary
    report << " "
    report << "Total candidates:          #{"%11d" % $total_candidates}"
    report << "Total configs tested:      #{"%11d" % summary["total"]}"
    report << "  Total executed:          #{"%11d" % summary["tested"]}"
    report << "  Total cached:            #{"%11d" % summary["cached"]}"
    report << "  Total passed:            #{"%11d" % summary["pass"]}"
    report << "    Total skipped:         #{"%11d" % summary["skipped"]}"
    report << "  Total failed:            #{"%11d" % summary["fail"]}"
    report << "  Total aborted:           #{"%11d" % summary["error"]}"
    report << "Done.  [Total elapsed walltime: #{format_time(elapsed)}]"
    report << " "
    add_to_mainlog(report.join("\n"))
    puts report.join("\n")

    # wtf = wall time file
    # what did *you* think it meant?!?!?
    #
    wtf = File.new($walltime_fn,"w")
    wtf.puts elapsed.to_s
    wtf.close

end # }}}


# Helper routines

# {{{ initialization


def read_craft_driver
    IO.foreach("#{$search_path}#{$craft_driver}") do |line|
        if line =~ /^#\s*BINARY\s*=\s*(.*)/ then
            $binary_name = File.basename($1)
            $binary_path = File.expand_path($1)
        elsif line =~ /^#\s*NUM_WORKERS\s*=\s*(\d+)/ then
            $num_workers = $1.to_i
        elsif line =~ /^#\s*PREFERRED_STATUS\s*=\s*(.)/ then
            $status_preferred = $1
        elsif line =~ /^#\s*ALTERNATE_STATUS\s*=\s*(.)/ then
            $status_alternate = $1
        elsif line =~ /^#\s*INITIAL_CFG\s*=\s*(\w+)/ then
            $initial_cfg_fn = $1
        elsif line =~ /^#\s*CACHED_CFGS\s*=\s*(\w+)/ then
            $cached_fn = $1
        elsif line =~ /^#\s*FORTRAN_MODE\s*=\s*(\w+)/ then
            if $1 == "yes" then
                $fortran_mode = true
            end
        elsif line =~ /^#\s*BASE_TYPE\s*=\s*(\w*)/ then
            type = $1.chomp.downcase
            if type =~ /ins/ then
                $base_type = $TYPE_INSTRUCTION
            elsif type =~ /block/ then
                $base_type = $TYPE_BASICBLOCK
            elsif type =~ /func/ then
                $base_type = $TYPE_FUNCTION
            elsif type =~ /mod/ then
                $base_type = $TYPE_MODULE
            elsif type =~ /app/ then
                $base_type = $TYPE_APPLICATION
            end
        elsif line =~ /^#\s*SEARCH_STRAT\s*=\s*(\w+)/ then
            if not ($1 == "default") then
                $strategy_name = $1
            end
        end
    end
end


def parse_command_line
    $main_mode = ARGV.shift.strip.downcase
    if $main_mode == "search" then
        $main_mode = "start"
    end
    if not ["start","resume","worker","status","help","clean"].include?($main_mode) then
        puts "Invalid mode: #{$main_mode}"
        exit
    end
    if $main_mode == "worker" then
        $worker_id = ARGV.shift
        $search_path = ARGV.shift
    end
    parsed_binary = false
    while ARGV.size > 0 do
        opt = ARGV.shift
        if $main_mode == "start" then
            if opt == "-j" then
                # parallel: "-j 4" variant
                $num_workers = ARGV.shift.to_i
            elsif opt =~ /^-j/ then
                # parallel: "-j4" variant
                $num_workers = opt[2,opt.length-2].to_i
            elsif opt == "-d" then
                # debug mode
                $status_preferred = ARGV.shift
                $status_alternate = $STATUS_IGNORE
                $fpconf_options = $FPCONF_OPTS[$status_preferred]
            elsif opt == "-D" then
                # debug mode
                $status_preferred = ARGV.shift
                $status_alternate = ARGV.shift
                $fpconf_options = $FPCONF_OPTS[$status_preferred]
            elsif opt == "-A" then
                # archived/cached configuration results
                $cached_fn = File.expand_path(ARGV.shift)
            elsif opt == "-c" then
                # initial configuration
                $initial_cfg_fn = ARGV.shift
            elsif opt == "-C" then
                # initial fpconf options
                $fpconf_options = ARGV.shift
            elsif opt == '-m' then
                # memory-based analysis
                $fpconf_options = "-c --svinp mem_double "
            elsif opt == '-r' then
                # reduced-precision analysis
                $status_preferred = $STATUS_RPREC
                $status_alternate = $STATUS_IGNORE
                $fpconf_options = "-c --rprec 52"
                $strategy_name = "rprec"
            elsif opt == '-a' then
                # skip non-executed configs
                $skip_nonexecuted = false
            elsif opt == '-N' then
                # fortran mode
                $fortran_mode = true
            elsif opt == '-b' then
                # stop splitting at basic blocks
                $base_type = $TYPE_BASICBLOCK
            elsif opt == '-f' then
                # stop splitting at functions
                $base_type = $TYPE_FUNCTION
            elsif opt == '-F' then
                # don't run final config
                $run_final_config = false
            elsif opt == '-s' then
                # strategy
                $strategy_name = ARGV.shift
            elsif opt == '--mixed-use_rprec' then
                # precision split threshold for reduced precision simulation of
                # mixed precision
                $mixed_use_rprec = true
                $rprec_split_threshold = ARGV.shift.to_i
            elsif opt == '--rprec-split_threshold' then
                # precision split threshold for reduced precision
                $rprec_split_threshold = ARGV.shift.to_i
            elsif opt == '--rprec-runtime_pct_threshold' then
                # runtime percentage threshold for reduced precision
                $rprec_runtime_pct_threshold = ARGV.shift.to_f
            elsif opt == '--rprec-skip_app_level' then
                # runtime percentage threshold for reduced precision
                $rprec_skip_app_level = true
            elsif opt == '-S' then
                # disable workqueue sorting
                $disable_queue_sort = true
            elsif !parsed_binary then
                if not File.exists?(opt) then
                    puts "Cannot find target binary: #{opt}"
                    exit
                end
                $binary_name = File.basename(opt)
                $binary_path = File.expand_path(opt)
                parsed_binary = true
            else
                if parsed_binary then
                    puts "Invalid parameter after target binary: #{opt}"
                    exit
                else
                    puts "Invalid resume parameter: #{opt}"
                    exit
                end
            end
        elsif $main_mode == "resume" then
            if opt == "-j" then
                # parallel: "-j 4" variant
                $num_workers = ARGV.shift.to_i
            elsif opt =~ /^-j/ then
                # parallel: "-j4" variant
                $num_workers = opt[2,opt.length-2].to_i
            elsif opt == "-l" then
                $resume_lower = true
            elsif opt == "-n" then
                $restart_inproc = true
            else
                puts "Invalid resume option: #{opt}"
                exit
            end
        else
            puts "Invalid parameter: #{opt}"
            exit
        end
    end
    if $main_mode == "start" and !parsed_binary then
        puts "No binary included on command-line."
        exit
    end
end


def initialize_program
    $program = nil
    mod = nil
    func = nil
    bblk = nil
    prolog = ""
    IO.foreach($orig_config_fn) do |line|
        if line =~ /(APPLICATION #\d+: [x0-9A-Fa-f]+) \"(.+)\"/ then
            $program = PPoint.new($1, $TYPE_APPLICATION, line[1,1])
            $program.attrs["desc"] = $2
        elsif line =~ /(MODULE #\d+: 0x[0-9A-Fa-f]+) \"(.+)\"/ then
            mod = PPoint.new($1, $TYPE_MODULE, line[1,1])
            mod.attrs["desc"] = $2
            $program.children << mod if $program != nil
        elsif line =~ /(FUNC #\d+: 0x[0-9A-Fa-f]+) \"(.+)\"/ then
            func = PPoint.new($1, $TYPE_FUNCTION, line[1,1])
            func.attrs["desc"] = $2
            mod.children << func if mod != nil
        elsif line =~ /(BBLK #\d+: (0x[0-9A-Fa-f]+))/ then
            bblk = PPoint.new($1, $TYPE_BASICBLOCK, line[1,1])
            bblk.attrs["addr"] = $2
            func.children << bblk if func != nil
        elsif line =~ /(INSN #\d+: (0x[0-9A-Fa-f]+)) \"(.+)\"/ then
            insn = PPoint.new($1, $TYPE_INSTRUCTION, line[1,1])
            insn.attrs["addr"] = $2
            insn.attrs["desc"] = $3
            bblk.children << insn if bblk != nil
        else
            prolog << line.chomp
            prolog << "\n"
        end
    end
    $program.build_lookup_hash if $program != nil
    $program.attrs["prolog"] = prolog
    if $program.nil? then
        puts "Unable to initialize program control structure."
        puts "Aborting search."
        exit
    end
end

def initialize_strategy
    if $strategy_name == "simple" then
        $strategy = Strategy.new($program, $status_preferred, $status_alternate)
    elsif $strategy_name == "bin_simple" then
        $strategy = BinaryStrategy.new($program, $status_preferred, $status_alternate)
    elsif $strategy_name == "exhaustive" then
        $strategy = ExhaustiveStrategy.new($program, $status_preferred, $status_alternate)
    elsif $strategy_name == "rprec" then
        $strategy = RPrecStrategy.new($program, $status_preferred, $status_alternate)
        $strategy.split_threshold = $rprec_split_threshold
        $strategy.runtime_pct_threshold = $rprec_runtime_pct_threshold
        $strategy.skip_app_level = $rprec_skip_app_level
    elsif $strategy_name == "ddebug" then
        $strategy = DeltaDebugStrategy.new($program, $status_preferred, $status_alternate)
    else
        puts "Unrecognized search strategy \"#{$strategy_name}\""
        puts "Aborting search."
        exit
    end
    $strategy.base_type = $base_type
    if $program.attrs.has_key?("icount") then
        $total_candidates = $program.attrs["icount"]
    else
        $total_candidates = 0
    end
end


def run_baseline_performance
    passed = false
    if not File.exist?($perf_path) then
        Dir.mkdir($perf_path)
    end
    Dir.chdir($perf_path)
    $baseline_error = 0.0
    $baseline_runtime = 1
    cmd = "#{$search_path}#{$craft_driver} #{$binary_path}"
    Open3.popen3(cmd) do |io_in, io_out, io_err|
        io_out.each_line do |line|
            if line =~ /status:\s*(pass|fail)/i then
                if $1 =~ /pass/i then
                    passed = true
                end
            end
            if line =~ /error:\s*(.+)/i then
                $baseline_error = $1.to_f
            end
            if line =~ /time:\s*(.+)/i then
                $baseline_runtime = [1, $1.to_i].max
            end
        end
    end
    Dir.chdir($search_path)
    return passed
end


def run_profiler
    passed = false
    if not File.exist?($prof_path) then
        Dir.mkdir($prof_path)
    end
    Dir.chdir($prof_path)

    # run mutator
    cmd = "#{$fpinst_invoke} -i --cinst #{$binary_path}"
    Open3.popen3(cmd) do |io_in, io_out, io_err|
        io_out.each_line do |line| end
    end

    # run rewritten mutatee
    cmd = "#{$search_path}#{$craft_driver} #{Dir.getwd}/mutant"
    Open3.popen3(cmd) do |io_in, io_out, io_err|
        io_out.each_line do |line|
            if line =~ /status:\s*(pass|fail)/i then
                if $1 =~ /pass/i then
                    passed = true
                end
            end
        end
    end

    # extract log file name
    if passed then
        $prof_log_fn = "#{Dir.getwd}/#{Dir.glob("*-c_inst*.log").first}"
    end

    Dir.chdir($search_path)
    return passed
end


def read_profiler_data
    pt_by_id = Hash.new

    if File.exists?($prof_log_fn) then

        # read individual instruction counts from log file

        # pass 1: extract ID => point mappings
        IO.foreach($prof_log_fn) do |line|
            if line =~ /instruction id="(\d+)" address="([x0-9a-zA-Z]+)"/ then
                pt_by_id[$1] = $program.lookup_by_addr($2)
            end
        end

        # pass 2: read counts
        cur_count = ""
        IO.foreach($prof_log_fn) do |line|
            if line =~ /priority="(\d+)" type="InstCount"/ then
                cur_count = $1
            end
            if line=~ /<inst_id>(\d+)<\/inst_id>/ then
                cur_id = $1
                cur_pt = pt_by_id[cur_id]
                if not cur_pt.nil? and cur_pt.orig_status == $STATUS_CANDIDATE then
                    # only count candidates
                    cur_pt.attrs["cinst"] = cur_count
                end
            end
        end
    end

    # propogate instruction counts up to the root
    update_cinst($program)
end

def update_cinst (pt)
    if not pt.attrs.has_key?("cinst") then
        total_cinst = 0
        pt.children.each do |child|
            update_cinst(child)
            total_cinst += child.attrs["cinst"].to_i
        end
        pt.attrs["cinst"] = total_cinst.to_s
    end
end


# }}}
# {{{ configuration testing


def calculate_pct_stats (cfg)
    pct_icount = 0
    pct_cinst = 0
    cfg.exceptions.keys.each do |k|
        pt = $program.lookup_by_uid(k)
        if !pt.nil? then
            pct_icount += pt.attrs["icount"].to_i
            pct_cinst += pt.attrs["cinst"].to_i
            if cfg.exceptions.keys.size == 1 then
                cfg.attrs["single_type"] = pt.type
            end
        end
    end
    pct_icount = (pct_icount.to_f / $program.attrs["icount"].to_f * 100.0).to_s
    pct_cinst = (pct_cinst.to_f / $program.attrs["cinst"].to_f * 100.0).to_s
    cfg.attrs["pct_icount"] = pct_icount.to_s
    cfg.attrs["pct_cinst"] = pct_cinst.to_s
end

def run_config (cfg)

    # write actual configuration file
    cfg_path = $search_path + cfg.filename
    $program.build_config_file(cfg, cfg_path)

    # pass off to filename version
    result,error,runtime = run_config_file(cfg_path, false, cfg.label)

    # save result
    cfg.attrs["result"] = result
    cfg.attrs["error"] = error
    cfg.attrs["runtime"] = runtime

    # delete actual configuration file
    FileUtils.rm_rf(cfg_path)

    return result
end

def run_config_file (fn, keep, label)

    # status updates
    basename = File.basename(fn)
    if basename =~ /^#{$binary_name}(.*)/ then
        basename = $1
    end
    #puts "  Testing #{basename} ..."
    $status_buffer = "    Finished testing #{label}:\n"

    # build rewritten mutatee
    cmd = "#{$fpinst_invoke} -i #{$fortran_mode ? "-N" : ""}"
    cmd += " -c #{fn}"
    cmd += " #{$binary_path}"
    #add_to_mainlog("    Building mutatee for #{basename}: #{cmd}")
    Open3.popen3(cmd) do |io_in, io_out, io_err|
        io_out.each_line do |line|
            if line =~ /Inplace: (.*)$/ then
                $status_buffer += "        #{$1}\n"
            end
        end
     end

    # execute rewritten mutatee and check for success
    result = $RESULT_ERROR
    runtime = 0
    error = 0.0
    cmd = "#{$search_path}#{$craft_driver} #{Dir.getwd}/mutant"
    #add_to_mainlog("    Testing mutatee for #{basename}: #{cmd}")
    Open3.popen3(cmd) do |io_in, io_out, io_err|
        io_out.each_line do |line|
            if line =~ /status:\s*(pass|fail)/i then
                tmp = $1
                if tmp =~ /pass/i then
                    result = $RESULT_PASS
                elsif tmp =~ /fail/i then
                    result = $RESULT_FAIL
                end
            elsif line =~ /error:\s*(.+)/i then
                error = $1.to_f
            elsif line =~ /time:\s*(.+)/i then
                runtime = $1.to_i
            end
        end
    end

    # scan log file(s) for info
    Dir.glob("*.log").each do |lfn|
        if lfn != "fpinst.log" then
            IO.foreach(lfn) do |line|
                if line =~ /Inplace: (.*)$/ then
                    $status_buffer += "        #{$1.gsub(/<.*>/, "")}\n"
                end
            end
        end
    end

    # print output
    $status_buffer += "        #{result}"
    $status_buffer += "  [Walltime: #{format_time(runtime.to_f)}"
    $status_buffer += " %.1fX"%[runtime / $baseline_runtime.to_f]
    $status_buffer += " Error: %g]"%[error]
    puts $status_buffer
    add_to_mainlog($status_buffer)
    if keep then
        f = File.new("result.txt", "w")
        f.puts $status_buffer
        f.close
    end
    $status_buffer = ""

    # copy config to appropriate folder
    if result == $RESULT_PASS then
        FileUtils.cp(fn, $passed_path)
    elsif result == $RESULT_FAIL then
        FileUtils.cp(fn, $failed_path)
    elsif result == $RESULT_ERROR then
        FileUtils.cp(fn, $aborted_path)
    end

    # clean out mutant, logs, and rewritten library files
    if !keep then
        begin
            toDelete = Array.new
            Dir.glob("*").each do |lfn|
                toDelete << lfn
                #if lfn =~ /mutant/ || lfn =~ /\.log/ || lfn =~ /lib(c|m)\.so\.6/ then
                #if lfn =~ /mutant/ || lfn =~ /\.log/ || lfn =~ /\.so$/ then
                    #File.delete(lfn)
                #end
            end
            toDelete.each do |fn|
                File.delete(fn)
            end
        rescue
            puts "Error clearing old files"
        end
    end

    return [result,error,runtime]
end


# }}}
# {{{ file manipulation


# FOR THE SYSTEM TO WORK, ALL OF THESE I/O ROUTINES *MUST* BE ATOMIC!
# None should be able to interrupt or starve another. This means that
# we need to lock the file in each function, and no function should
# call another.


def save_settings
    f = File.new($settings_fn, "r+")
    f.flock File::LOCK_EX
    f.truncate(0)

    f.puts "start_time=#{$start_time.to_i}"
    f.puts "binary_name=#{$binary_name}"
    f.puts "binary_path=#{$binary_path}"
    f.puts "strategy_name=#{$strategy_name}"
    f.puts "status_preferred=#{$status_preferred}"
    f.puts "status_alternate=#{$status_alternate}"
    f.puts "baseline_runtime=#{$baseline_runtime}"
    f.puts "lang=#{($fortran_mode ? "fortran" : "other")}"
    f.puts "base_type=#{$base_type}"
    f.puts "skip_nonexecuted=#{$skip_nonexecuted}"
    f.puts "initial_cfg_fn=#{$initial_cfg_fn}"
    f.puts "cached_fn=#{$cached_fn}"
    f.puts "prof_log_fn=#{$prof_log_fn}"
    f.puts "total_candidates=#{$total_candidates}"
    f.puts "rprec_split_threshold=#{$rprec_split_threshold}"
    f.puts "rprec_runtime_pct_threshold=#{$rprec_runtime_pct_threshold}"
    f.puts "rprec_skip_app_level=#{$rprec_skip_app_level}"
    f.puts "disable_queue_sort=#{$disable_queue_sort.to_s}"
    f.puts "run_final_config=#{$run_final_config.to_s}"
    f.puts "mixed_use_rprec=#{$mixed_use_rprec.to_s}"

    #f.puts $start_time.to_i
    #f.puts $binary_name
    #f.puts $binary_path
    #f.puts $strategy_name
    #f.puts $status_preferred
    #f.puts $status_alternate
    #f.puts $baseline_runtime
    #f.puts($fortran_mode ? "fortran" : "other")
    #f.puts $base_type
    #f.puts $skip_nonexecuted
    #f.puts $initial_cfg_fn
    #f.puts $prof_log_fn
    #f.puts $total_candidates
    #f.puts $rprec_split_threshold
    #f.puts $rprec_runtime_pct_threshold
    #f.puts $rprec_skip_app_level
    #f.puts $disable_queue_sort
    #f.puts $run_final_config
    #f.puts $mixed_use_rprec

    f.close
end
def load_settings
    f = File.new($settings_fn, "r")
    f.flock File::LOCK_SH
    parser = /^\s*(\w+)\s*=\s*(.*)\s*$/
    temp = f.gets
    if temp =~ parser then
        while temp != nil and temp =~ parser do
            key = $1
            value = $2
            case key
            when "start_time"
                $start_time = Time.at(value.to_i)
            when "binary_name"
                $binary_name = value
            when "binary_path"
                $binary_path = value
            when "strategy_name"
                $strategy_name = value
            when "status_preferred"
                $status_preferred = value
            when "status_alternate"
                $status_alternate = value
            when "baseline_runtime"
                $baseline_runtime = value.to_i
            when "lang"
                if value == "fortran" then $fortran_mode = true
                else                       $fortran_mode = false
                end
            when "base_type"
                $base_type = value
            when "skip_nonexecuted"
                $skip_nonexecuted = (value == true.to_s)
            when "cached_fn"
                $cached_fn = value
            when "initial_cfg_fn"
                $initial_cfg_fn = value
            when "prof_log_fn"
                $prof_log_fn = value
            when "total_candidates"
                $total_candidates = value.to_i
            when "rprec_split_threshold"
                $rprec_split_threshold = value.to_i
            when "rprec_runtime_pct_threshold"
                $rprec_runtime_pct_threshold = value.to_f
            when "rprec_skip_app_level"
                $rprec_skip_app_level = (value == true.to_s)
            when "disable_queue_sort"
                $disable_queue_sort = (value == true.to_s)
            when "run_final_config"
                $run_final_config = (value == true.to_s)
            when "mixed_use_rprec"
                $mixed_use_rprec = (value == true.to_s)
            end
            temp = f.gets
        end
    else
        # old style settings file; included for backwards compatibility
        $start_time = Time.at(temp.to_i)
        $binary_name = f.gets.chomp
        $binary_path = f.gets.chomp
        $strategy_name = f.gets.chomp
        $status_preferred = f.gets.chomp
        $status_alternate = f.gets.chomp
        $baseline_runtime = f.gets.chomp.to_i
        lang = f.gets.chomp
        if lang == "fortran" then
            $fortran_mode = true
        else
            $fortran_mode = false
        end
        $base_type = f.gets.chomp
        $skip_nonexecuted = (f.gets.chomp == true.to_s)
        $initial_cfg_fn = f.gets.chomp
        line = f.gets; $prof_log_fn           = (line != nil ? line.chomp      : "")
        line = f.gets; $total_candidates      = (line != nil ? line.chomp.to_i : 0)
        line = f.gets; $rprec_split_threshold = (line != nil ? line.chomp.to_i : 0)
        line = f.gets; $rprec_runtime_pct_threshold = (line != nil ? line.chomp.to_i : 0)
        line = f.gets; $rprec_skip_app_level  = (line != nil ? line.chomp == true.to_s : false)
        line = f.gets; $disable_queue_sort    = (line != nil ? line.chomp == true.to_s : false)
        line = f.gets; $run_final_config      = (line != nil ? line.chomp == true.to_s : false)
        line = f.gets; $mixed_use_rprec       = (line != nil ? line.chomp == true.to_s : false)
    end
    f.close
end


def read_cfg_array(io)
    configs = Array.new
    begin
        line = io.readline.chomp
        if line == "BINARY" then
            configs = Marshal.load(io)
        else
            io.rewind
            YAML.load_stream(io).each do |doc|
                configs << doc
            end
        end
    rescue
    end
    return configs
end

def write_cfg_array(configs, io)
    if $binary_serialization then
        io.puts "BINARY"
        Marshal.dump(configs, io)
    else
        configs.each do |doc|
            YAML.dump(doc, io)
        end
    end
end

def add_to_workqueue_bulk(configs)
    f = File.new("#{$workqueue_fn}", "r+")
    f.flock File::LOCK_EX
    queue = read_cfg_array(f)
    configs.each do |cfg|
        calculate_pct_stats(cfg)
        queue << cfg
        puts "Added config #{cfg.label} to workqueue."
    end
    if not $disable_queue_sort then
        queue.sort!
    end
    f.truncate(0)
    f.pos = 0
    write_cfg_array(queue, f)
    f.close
end

def add_to_workqueue(cfg)
    f = File.new("#{$workqueue_fn}", "r+")
    f.flock File::LOCK_EX
    queue = read_cfg_array(f)
    calculate_pct_stats(cfg)
    queue << cfg
    if not $disable_queue_sort then
        queue.sort!
    end
    
    # debug output
    #puts "Current workqueue:"
    #queue.each do |c|
        #puts "  - #{c.label}"
    #end
    
    f.truncate(0)
    f.pos = 0
    write_cfg_array(queue, f)
    f.close
end
def get_next_workqueue_item
    next_cfg = nil
    f = File.new($workqueue_fn, "r+")
    f.flock File::LOCK_EX
    queue = read_cfg_array(f)
    next_cfg = queue.shift
    f.pos = 0
    write_cfg_array(queue, f)
    f.truncate(f.pos)
    f.close
    return next_cfg
end
def get_workqueue_configs
    f = File.new("#{$workqueue_fn}", "r")
    f.flock File::LOCK_SH
    queue = read_cfg_array(f)
    f.close
    return queue
end
def get_workqueue_length
    len = 0
    f = File.new($workqueue_fn, "r")
    f.flock File::LOCK_SH
    queue = read_cfg_array(f)
    len = queue.size
    f.close
    return len
end


def add_to_inproc(cfg)
    f = File.new($inproc_fn, "r+")
    f.flock File::LOCK_EX
    inproc = read_cfg_array(f)
    inproc << cfg
    f.pos = 0
    write_cfg_array(inproc, f)
    f.truncate(f.pos)
    f.close
end
def remove_from_inproc(cfg)
    inproc = Array.new
    f = File.new($inproc_fn, "r+")
    f.flock File::LOCK_EX
    configs = read_cfg_array(f)
    configs.each do |cfg|
        inproc << cfg if not (cfg.cuid == cfg.cuid)
    end
    f.pos = 0
    write_cfg_array(inproc, f)
    f.truncate(f.pos)
    f.close
end
def get_inproc_configs
    f = File.new("#{$inproc_fn}", "r")
    f.flock File::LOCK_SH
    inproc = read_cfg_array(f)
    f.close
    return inproc
end
def get_inproc_length
    len = 0
    f = File.new($inproc_fn, "r")
    f.flock File::LOCK_SH
    inproc = read_cfg_array(f)
    len = inproc.size
    f.close
    return len
end
def move_all_inproc_to_workqueue
    f = File.new($inproc_fn, "r+")
    f.flock File::LOCK_EX
    configs = read_cfg_array(f)
    add_to_workqueue_bulk(configs)
    f.truncate(0)
    f.close
end


def add_tested_config(cfg)
    f = File.new($tested_fn, "a")
    f.flock File::LOCK_EX
    YAML.dump(cfg, f)
    f.close
end
def get_tested_configs
    tested = Array.new
    f = File.new("#{$tested_fn}", "r")
    f.flock File::LOCK_SH
    YAML.load_stream(f).each do |doc|
        tested << doc
    end
    f.close
    return tested
end
def get_tested_config_count
    len = 0
    f = File.new("#{$tested_fn}", "r")
    f.flock File::LOCK_SH
    YAML.load_stream(f).each do |doc|
        len += 1
    end
    f.close
    return len
end


def load_cached_configs
    if ($cached_configs.size == 0) and (not $cached_fn == "") and (File.exists?($cached_fn)) then
        f = File.new("#{$cached_fn}", "r")
        f.flock File::LOCK_SH
        ydocs = YAML.load_stream(f)
        f.close
        if not ydocs.nil? then
            ydocs.documents.each do |doc|
                $cached_configs << doc
            end
        end
    end
end


def add_to_mainlog(reg)
    f = File.new($mainlog_fn, "a")
    f.flock File::LOCK_EX
    f.puts(reg.to_s)
    f.close
end
def load_mainlog
    f = File.new($mainlog_fn, "r")
    f.flock File::LOCK_SH
    lines = f.readlines
    f.close
    return lines
end


# }}}
# {{{ output


def print_usage
    puts " "
    puts "CRAFT #{$CRAFT_VERSION}"
    puts "Automatic search script"
    puts " "
    puts "Usage:  #{$self_invoke} start [start-options] <binary>     (supervisor process)"
    puts "        #{$self_invoke} search [start-options] <binary>    (supervisor process)"
    puts "          or"
    puts "        #{$self_invoke} resume [resume-options]            (resume supervisor process)"
    puts "          or"
    puts "        #{$self_invoke} status                             (display search status)"
    puts "          or"
    puts "        #{$self_invoke} clean                              (reset search)"
    puts "          or"
    puts "        #{$self_invoke} worker <id> <dir>                  (worker process; used internally)"
    puts " "
    puts "Shortcut mode modifications:"
    puts "   <default>      operation-based mixed-precision analysis"
    puts "   -m             memory-based mixed-precision analysis"
    puts "                    equivalent to '-C \"-c --svinp mem_double\"'"
    puts "   -r             reduced-precision analysis"
    puts "                    equivalent to '-d #{$STATUS_RPREC} -s \"rprec\" -C \"-c --rprec 52\"'"
    puts " "
    puts "Initiation options:"
    puts "   -a             test all generated configs (don't skip non-executed instructions)"
    puts "   -A <file>      use an archived craft.tested file to avoid re-running tests from a previous search"
    puts "   -b             stop splitting configs at the basic block level"
    puts "   -c <file>      use <file> as initial base configuration"
    puts "   -C \"<opts>\"    pass the given options to fpconf to generate initial base configuration"
    puts "   -d <p>         debug mode (<p> -> ignore instead of double->single)"
    puts "   -D <p> <a>     debug mode (<p> -> <a> instead of double->single)"
    puts "                    (-d and -D also adjust the fpconf options appropriately)"
    puts "   -f             stop splitting configs at the function level"
    puts "   -F             don't test final configuration"
    puts "   -j <np>        spawn <np> worker threads"
    puts "   -N             enable Fortran mode (passes \"-N\" to fpinst)"
    puts "   -s <name>      use <name> strategy (default is \"bin_simple\")"
    puts "                    valid strategies:  \"simple\", \"bin_simple\", \"exhaustive\", \"rprec\""
    puts "   -S             disable queue sorting (improves overall performance but may converge slower"
    puts " "
    puts "Mixed-precision-specific options:"
    puts "   --mixed-use_rprec <X>                  use reduced-precision to simulate <X> bits for single precision"
    puts " "
    puts "Reduced-precision-specific options:"
    puts "   --rprec-split_threshold <X>            don't descend into nodes with <=X bits of precision"
    puts "   --rprec-runtime_pct_threshold <X>      don't descend into nodes with <X% runtime execution"
    puts "   --rprec-skip_app_level                 don't test at the whole-application level"
    puts " "
    puts "Resumption options:"
    puts "   -j <np>        spawn <np> worker threads"
    puts "   -l             resume search at lower level (e.g., INSN instead of BBLK)"
    puts "   -n             resume search and restart in-process tests"
    puts " "
    puts "Using Ruby #{RUBY_VERSION} #{RUBY_RELEASE_DATE}"
    puts " "
end


def get_worker_thread_count
    cmd = "ps -C #{$self_invoke} -o s="
    psr = `#{cmd}`
    num_workers = [0,psr.lines.count - ($main_mode == "status" ? 2 : 1)].max
    return num_workers
end


def get_status
    overall_status = "not running"
    if File.exist?($settings_fn) then
        begin
            load_settings
            overall_status = "initializing"
            overall_status = "waiting" if File.exist?($workqueue_fn)
            overall_status = "running" if (get_workqueue_length > 0 or get_inproc_length > 0)
            overall_status = "finalizing" if File.exist?($final_path)
            overall_status = "DONE" if File.exist?($walltime_fn)
        rescue
            overall_status = "initializing"
        end
    end
    return overall_status
end


def print_status

    hbar   = "===================================================================================================="
    indent = "                            "
    ptag = Time.now.strftime("%Y-%m-%d %H:%M:%S %z")
    ftag = Time.now.strftime("status_%Y_%m_%d_%H_%M_%S_%z.txt")
    overall_status = get_status     # calls load_settings
    full_output = (overall_status == "waiting" or overall_status == "running" or
                   overall_status == "finalizing" or overall_status == "DONE")
    nworkers = get_worker_thread_count

    status_text = Array.new
    status_text << "Snapshot taken at #{ptag}"
    status_text << " "
    status_text << hbar
    status_text << "#{indent}                  CRAFT"

    # basic statistics (app, config count, queue size, etc.)
    if full_output then
        elapsed = Time.now.to_f - $start_time.to_f
        if File.exist?($walltime_fn) then
            elapsed = IO.readlines($walltime_fn)[0].to_f
        end
        status_text << "#{indent}Application: #{"%27s" % $binary_name}"
        #status_text << "#{indent}Fortran mode:  #{"%24s" % ($fortran_mode ? "Y" : "N")}"
        status_text << "#{indent}Base type:  #{"%28s" % $base_type}"
        status_text << "#{indent}Worker threads:            #{"%13d" % nworkers}"
        status_text << "#{indent}Total candidates:          #{"%13d" % $total_candidates}"
        summary = get_tested_configs_summary
        status_text << "#{indent}Total configs tested:      #{"%13d" % summary["total"]}"
        status_text << "#{indent}   Total executed:         #{"%13d" % summary["tested"]}"
        status_text << "#{indent}   Total cached:           #{"%13d" % summary["cached"]}"
        status_text << "#{indent}   Total passed:           #{"%13d" % summary["pass"]}"
        status_text << "#{indent}     Total skipped:        #{"%13d" % summary["skipped"]}"
        status_text << "#{indent}   Total failed:           #{"%13d" % summary["fail"]}"
        status_text << "#{indent}   Total aborted:          #{"%13d" % summary["error"]}"
        status_text << "#{indent}   Module-level:           #{"%13d" % summary[$TYPE_MODULE]}"
        status_text << "#{indent}   Function-level:         #{"%13d" % summary[$TYPE_FUNCTION]}"
        status_text << "#{indent}   Block-level:            #{"%13d" % summary[$TYPE_BASICBLOCK]}"
        status_text << "#{indent}   Instruction-level:      #{"%13d" % summary[$TYPE_INSTRUCTION]}"
        status_text << "#{indent}Current in-proc length:    #{"%13d" % get_inproc_length}"
        status_text << "#{indent}Current workqueue length:  #{"%13d" % get_workqueue_length}"
        status_text << "#{indent}Total elapsed walltime: #{"%16s" % format_time(elapsed)}"
    end
    status_text << "#{indent}Overall status:         #{"%16s" % overall_status}"
    status_text << hbar

    # best results so far and current in-process configs
    if full_output then
        report = build_best_report(8)
        report.each do |rl|
            status_text << rl
        end
        status_text << hbar if report.size > 0
        if get_inproc_length > 0 or get_workqueue_length > 0 then
            inproc = get_inproc_configs
            queue = get_workqueue_configs
            status_text << ""
            progress = "Current workqueue (" + (queue.size > inproc.size ? inproc.size : queue.size).to_s + "/" + queue.size.to_s + "):"
            status_text << "  Currently testing:                  STA\%   DYN\%   #{"%-33s"%progress}   STA\%   DYN\%"
            0.upto(inproc.size-1) do |i|
                line = ""
                if i < inproc.size then
                    icfg = inproc[i]
                    line += "    - %-30s %5.1f  %5.1f "%[format_text(icfg.label,30),icfg.attrs["pct_icount"],icfg.attrs["pct_cinst"]]
                else
                    line += "%50s"%" "
                end
                if i < queue.size then
                    qcfg = queue[i]
                    line += "    - %-30s %5.1f  %5.1f "%[format_text(qcfg.label,30),qcfg.attrs["pct_icount"],qcfg.attrs["pct_cinst"]]
                end
                status_text << line if line.strip != ""
            end
            if queue.size > inproc.size then
                status_text << "%50s      ..."%" "
            end
            status_text << ""
            status_text << hbar
        end
    end

    # print to stdout
    puts status_text

    # create snapshot file
    if !File.exist?($snapshot_path) then
        Dir.mkdir($snapshot_path)
    end
    f = File.new("#{$snapshot_path}#{ftag}", "w")
    f.puts status_text
    f.close

    # remove latest snapshot if it's a duplicate of the previous one
    all_snapshots = Dir.glob("#{$snapshot_path}status*.txt").sort { |f1,f2| File.mtime(f2) <=> File.mtime(f1) }
    if all_snapshots.size > 1 then
        newest_fn = all_snapshots.at(0)
        older_fn = all_snapshots.at(1)
        diff = `diff #{older_fn} #{newest_fn}`.split("\n")

        # 2 always-changing snapshot lines (timestamp + elapse walltime)
        # 4 diff lines per snapshot line (assumes default diff output)
        if diff.size <= 2*4 then
            File.delete(newest_fn)
        end
    end
end


def format_time (elapsed)
    mins, secs = elapsed.divmod 60.0
    hrs, mins = mins.divmod 60.0
    #return "%d:%02d:%05.2f"%[hrs.to_i, mins.to_i, secs]
    return "%d:%02d:%02d"%[hrs.to_i, mins.to_i, secs.to_i]
end


def format_text (str, width)
    if str.size > width then
        str = str[0,width-3] + "..."
    end
    return str
end


# }}}
# {{{ finalization and cleanup


def rebuild_final_config
    $final_config = $strategy.build_final_config(get_tested_configs)
    $program.build_config_file($final_config, $final_config_fn, false)
    calculate_pct_stats($final_config)
end


def is_single_base (cfg, type)
    isb = false
    if cfg.exceptions.keys.size == 1 then
        pt = $program.lookup_by_uid(cfg.exceptions.keys.first)
        if !pt.nil? and pt.type == type then
            isb = true
        end
    end
    return isb
end


def build_best_report(num,copy_files=false)
    if $strategy_name == "rprec" then
        return Array.new
    else
        return build_best_regular_report(num,copy_files)
    end
end

def build_reduced_prec_report(num,copy_files=false)
    results = get_tested_configs
    $strategy.reload_bounds_from_results(results)
    report = Array.new

    # TODO: iterate over $program and find the best bounds for each instruction
    #       then merge this with the icount and cinst info and report it all

    return report
end

def build_best_regular_report(num,copy_files=false)
    # find best individual configs
    results = get_tested_configs
    inst_passed_cfgs = Array.new
    exec_passed_cfgs = Array.new
    exec_passed_cfgs = Array.new
    inst_passed = 0.0
    exec_passed = 0.0
    inst_failed_cfgs = Array.new
    exec_failed_cfgs = Array.new
    inst_failed = 0.0
    exec_failed = 0.0
    results.each do |cfg|
        if not (cfg.cuid == $FINALCFG_CUID) then
            if cfg.attrs["result"] == $RESULT_PASS then
                inst_passed_cfgs << [cfg, cfg.attrs["pct_icount"].to_f]
                exec_passed_cfgs << [cfg, cfg.attrs["pct_cinst"].to_f]
                inst_passed += cfg.attrs["pct_icount"].to_f
                exec_passed += cfg.attrs["pct_cinst"].to_f
            else
                if cfg.attrs.has_key?("single_type") and cfg.attrs["single_type"] == $base_type then
                    inst_failed_cfgs << [cfg, cfg.attrs["pct_icount"].to_f]
                    exec_failed_cfgs << [cfg, cfg.attrs["pct_cinst"].to_f]
                    inst_failed += cfg.attrs["pct_icount"].to_f
                    exec_failed += cfg.attrs["pct_cinst"].to_f
                end
            end
        end
    end
    report = Array.new
    report << " "
    report << "  Top instrumented (passed):                STA\%    Top instrumented (failed/aborted):        STA\%"
    inst_passed_cfgs = inst_passed_cfgs.sort_by { |cfg,pct| -pct }
    inst_failed_cfgs = inst_failed_cfgs.sort_by { |cfg,pct| -pct }
    0.upto(num-1).each do |i|
        line = ""
        if i < inst_passed_cfgs.size then
            pcfg,ppct = inst_passed_cfgs[i]
            if copy_files and File.exists?($passed_path + pcfg.filename) then
                FileUtils.cp($passed_path + pcfg.filename, $best_path)
            end
            line += "    - %-35s  %5.1f  "%[format_text(pcfg.label,35),ppct]
        else
            line += "%50s"%" "
        end
        if i < inst_failed_cfgs.size then
            fcfg,fpct = inst_failed_cfgs[i]
            line += "    - %-35s  %5.1f  "%[format_text(fcfg.label,35),fpct]
        end
        report << line if line.strip != ""
    end
    report << " "
    report << "      %35s  %5.1f  "%["TOTAL PASSED",inst_passed] +
              "      %35s  %5.1f  "%["TOTAL FAILED",inst_failed]
    report << "%50s      %35s  %5.1f"%[" ","TOTAL",inst_passed+inst_failed]
    report << " "
    report << "  Top executed (passed):                    DYN\%    Top executed (failed/aborted):            DYN\%"
    exec_passed_cfgs = exec_passed_cfgs.sort_by { |cfg,pct| -pct }
    exec_failed_cfgs = exec_failed_cfgs.sort_by { |cfg,pct| -pct }
    0.upto(num-1).each do |i|
        line = ""
        if i < exec_passed_cfgs.size then
            pcfg,ppct = exec_passed_cfgs[i]
            if copy_files and File.exists?($passed_path + pcfg.filename) then
                FileUtils.cp($passed_path + pcfg.filename, $best_path)
            end
            line += "    - %-35s  %5.1f  "%[format_text(pcfg.label,35),ppct]
        else
            line += "%50s"%" " 
        end
        if i < exec_failed_cfgs.size then
            fcfg,fpct = exec_failed_cfgs[i]
            line += "    - %-35s  %5.1f  "%[format_text(fcfg.label,35),fpct]
        end
        report << line if line.strip != ""
    end
    report << " "
    report << "      %35s  %5.1f  "%["TOTAL PASSED",exec_passed] +
              "      %35s  %5.1f  "%["TOTAL FAILED",exec_failed]
    report << "%50s      %35s  %5.1f"%[" ","TOTAL",exec_passed+exec_failed]
    report << " "
    return report
end

def get_tested_configs_summary
    summary = Hash.new(0)
    tested_cfgs = get_tested_configs
    tested_cfgs.each do |cfg|
        if cfg.attrs.has_key?("result") then
            if cfg.attrs["result"] == $RESULT_PASS then
                summary["pass"] += 1
            elsif cfg.attrs["result"] == $RESULT_FAIL then
                summary["fail"] += 1
            elsif cfg.attrs["result"] == $RESULT_ERROR then
                summary["error"] += 1
            end
        end
        if cfg.attrs.has_key?("skipped") and cfg.attrs["skipped"] == "yes" then
            summary["skipped"] += 1
        end
        if cfg.attrs.has_key?("cached") and cfg.attrs["cached"] == "yes" then
            summary["cached"] += 1
        end
        if cfg.attrs.has_key?("level") then
            summary[cfg.attrs["level"]] += 1
        end
    end
    summary["total"] = tested_cfgs.size
    summary["tested"] = summary["total"] - summary["skipped"] - summary["cached"]
    return summary
end


def clean_everything
    toDelete = Array.new
    Dir.glob("#{$search_tag}.*") do |fn| toDelete << fn end
    Dir.glob("#{$search_tag}_*.cfg") do |fn| toDelete << fn end
    Dir.glob("*_worker*") do |fn| toDelete << fn end
    Dir.glob("*.log") do |fn| toDelete << fn end
    Dir.glob("baseline") do |fn| toDelete << fn end
    #Dir.glob("profile") do |fn| toDelete << fn end
    Dir.glob("final") do |fn| toDelete << fn end
    Dir.glob("best") do |fn| toDelete << fn end
    Dir.glob("passed") do |fn| toDelete << fn end
    Dir.glob("failed") do |fn| toDelete << fn end
    Dir.glob("aborted") do |fn| toDelete << fn end
    Dir.glob("snapshots") do |fn| toDelete << fn end
    toDelete.each do |fn|
        FileUtils.rm_rf(fn)
    end
end


# }}}


# top-level: call main
main

