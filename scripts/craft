#!/usr/bin/env ruby
#
# craft
#
# Generate floating-point precision configurations for a target application and
# test them. Assemble a final recommended configuration.
#
# Copyright (C) 2018 Mike Lam, UMD/JMU/LLNL
# Original version written October 2012
#

# needed for opening stderr as well as stdin/stdout
# when spawning new system processes
require 'open3'

# needed for object serialization
require 'yaml'

# needed for file manipulation and directory removal
require 'fileutils'

# needed for inter-tool JSON parsing and generating
require 'json'

# {{{ top-level: global constants

$CRAFT_VERSION = "1.1"                              # release version

$RESULT_PASS  = "Success!"                          # test result possibilities
$RESULT_FAIL  = "FAILED!"
$RESULT_ERROR = "ERROR!!!"

$TYPE_APPLICATION = "APPLICATION"                   # control point levels
$TYPE_MODULE      = "MODULE"
$TYPE_FUNCTION    = "FUNC"
$TYPE_BASICBLOCK  = "BBLK"
$TYPE_INSTRUCTION = "INSN"
$TYPE_VARIABLE    = "VAR"
$TYPE_SPACES = Hash.new("")
$TYPE_SPACES[$TYPE_APPLICATION] = ""                # for pretty output
$TYPE_SPACES[$TYPE_MODULE]      = "  "
$TYPE_SPACES[$TYPE_FUNCTION]    = "    "
$TYPE_SPACES[$TYPE_BASICBLOCK]  = "      "
$TYPE_SPACES[$TYPE_INSTRUCTION] = "        "
$TYPE_SPACES[$TYPE_VARIABLE]    = "        "
$TYPE_RANK = Hash.new(0)
$TYPE_RANK[$TYPE_APPLICATION] = 1
$TYPE_RANK[$TYPE_MODULE]      = 2
$TYPE_RANK[$TYPE_FUNCTION]    = 3
$TYPE_RANK[$TYPE_BASICBLOCK]  = 4
$TYPE_RANK[$TYPE_INSTRUCTION] = 5
$TYPE_RANK[$TYPE_VARIABLE]    = 5
$TYPE_RRANK = $TYPE_RANK.invert

$STATUS_NONE      = " "                             # replacement status posibilities
$STATUS_IGNORE    = "!"
$STATUS_SINGLE    = "s"
$STATUS_DOUBLE    = "d"
$STATUS_CANDIDATE = "?"
$STATUS_NULL      = "x"
$STATUS_CINST     = "i"
$STATUS_DCANCEL   = "c"
$STATUS_DNAN      = "n"
$STATUS_TRANGE    = "t"
$STATUS_RPREC     = "r"

$FPCONF_OPTS = Hash.new("")
$FPCONF_OPTS[$STATUS_SINGLE]  = "-c --svinp single"
$FPCONF_OPTS[$STATUS_DOUBLE]  = "-c --svinp double"
$FPCONF_OPTS[$STATUS_NULL]    = "-c --null"
$FPCONF_OPTS[$STATUS_CINST]   = "-c --cinst"
$FPCONF_OPTS[$STATUS_DCANCEL] = "-c --dcancel"
$FPCONF_OPTS[$STATUS_DNAN]    = "-c --dnan"
$FPCONF_OPTS[$STATUS_TRANGE]  = "-c --trange"
$FPCONF_OPTS[$STATUS_RPREC]   = "-c --rprec 52"

$FINALCFG_CUID = "FINAL"                            # special config; represents "best" final results

# }}}

# PPoint
#
# Represents a single control point in a program. There is a single APPLICATION
# PPoint at the root, and then it branches into modules, functions, etc. This
# keeps the entire program's structure in memory while only requiring a single
# copy (as older versions of this script did). The PPoint knows how to output
# actual configuration files (given a AppConfig object) that the mutator can use.
#
# {{{ PPoint
class PPoint
    attr_accessor :uid              # unique regex identifier; e.g. "INSN #34: 0x804d3f"
    attr_accessor :id               # program component identifier; e.g. 34 in line above
    attr_accessor :type             # module, function, instruction, etc.
    attr_accessor :orig_status      # single, double, ignore, candidate, none
    attr_accessor :parent           # PPoint
    attr_accessor :children         # array of PPoints
    attr_accessor :attrs            # string => string
    attr_accessor :byuid            # uid => PPoint          (for increased lookup speed)
    attr_accessor :byaddr           # addr => insn PPoint    (for increased lookup speed)

    def initialize (uid, type, orig_status)
        @uid = uid
        @id = 0
        if @uid =~ /#(\d+)/ then
            @id = $1.to_i
        end
        @type = type
        @orig_status = orig_status
        @parent = nil
        @children = Array.new
        @attrs = Hash.new
        @byuid = Hash.new
        @byaddr = Hash.new
    end

    def build_config_file (config, fn, only_insns=true)
        # write out a configuration file for this program and the given config
        # this method will only be called in an APPLICATION node; it calls
        # output() to recursively print the other levels
        fout = File.new(fn, "w")
        if @attrs.has_key?("prolog") then
            @attrs["prolog"].each_line do |line|
                if $mixed_use_rprec and only_insns then
                    if line =~ /^sv_inp/ then
                        if line.chomp == "sv_inp=yes" then
                            fout.puts "r_prec=yes"
                            fout.puts "r_prec_default_precision=52"
                        end
                    else
                        fout.puts line
                    end
                else
                    fout.puts line
                end
            end
        end
        if only_insns then
            output(config, fout, nil, nil)
        else
            output_all(config, fout)
        end
        fout.close
    end

    def build_typeforge_file (config, fn)
        File.open(fn, "w") do |f|
            output_typeforge(config, f, nil, "$global")
        end
    end

    def build_json_file (config, fn)
        fout = Hash.new
        fout["version"] = "1"
        fout["tool_id"] = "CRAFT"
        fout["source_files"] = []
        actions = []
        output_json(config, actions, nil)
        fout["actions"] = actions
        File.open(fn, "w") do |f|
            f.puts(JSON.pretty_generate(fout))
        end
    end

    def build_lookup_hash(pt=nil)
        if pt.nil? then
            @byuid[@uid] = self
            @children.each do |child|
                build_lookup_hash(child)
            end
        else
            if pt.type == $TYPE_INSTRUCTION and pt.attrs.has_key?("addr") then
                @byaddr[pt.attrs["addr"]] = pt
            end
            @byuid[pt.uid] = pt
            pt.children.each do |child|
                build_lookup_hash(child)
            end
        end
    end

    def lookup_by_uid(uid)
        return @byuid[uid]
    end

    def lookup_by_addr(addr)
        return @byaddr[addr]
    end

    def build_cuid(tag = nil)
        cuid = @uid
        if not tag.nil? then
            cuid += " #{tag}"
        end
        return cuid
    end

    def build_label(tag = nil)
        # build human-readable label
        label = @uid
        if tag.nil? then
            tag = ""
        else
            tag += " "
        end
        if @uid.include?($TYPE_APPLICATION) then
            label = "APP #{tag}#{@attrs["desc"]}"
        elsif @uid.include?($TYPE_MODULE) then
            label = "MOD #{tag}#{@attrs["desc"]}"
        elsif @uid.include?($TYPE_FUNCTION) then
            label = "FUNC #{tag}#{@attrs["desc"]}"
        elsif @uid.include?($TYPE_BASICBLOCK) then
            label = "BBLK #{@attrs["addr"]} #{tag}"
        elsif @uid.include?($TYPE_INSTRUCTION) then
            label = "INSN #{@attrs["addr"]} #{tag}\"#{@attrs["desc"]}\""
        elsif @uid.include?($TYPE_VARIABLE) then
            label = "VAR #{@attrs["addr"]} #{tag}\"#{@attrs["desc"]}\""
        end
        return label.strip
    end

    def output_all(config, fout)
        prec_line = nil
        fout.print("^")
        if config.exceptions.has_key?(@uid) then
            # status overridden by current config
            fout.print(config.exceptions[@uid])
            if config.exceptions[@uid] == $STATUS_RPREC then
                prec_line = "#{type}_#{@id}_precision=#{config.precisions[@uid]}"
            end
        else
            if @orig_status == $STATUS_CANDIDATE then
                # candidate for replacement; output configuration default
                fout.print(config.default)
            else
                # no override; output original default
                fout.print(@orig_status)
            end
        end
        fout.print(" ")
        fout.print($TYPE_SPACES[@type])     # indentation
        fout.print(@uid)
        if @attrs.has_key?("desc") then
            fout.print(" \"")
            fout.print(@attrs["desc"])
            fout.print("\"")
        end
        fout.print("\n")
        if not prec_line.nil? then
            fout.puts prec_line
        end
        @children.each do |pt|
            pt.output_all(config, fout)
        end
    end

    def output(config, fout, overload, overload_prec)
        prec_line = nil
        fout.print("^")
        if type == $TYPE_INSTRUCTION then
            flag = @orig_status
            if @orig_status == $STATUS_CANDIDATE then
                # candidate for replacement; check to see if we should
                if not overload.nil? then
                    # status overridden by something higher up the tree
                    flag = overload
                    if overload == $STATUS_RPREC then
                        prec_line = "#{type}_#{@id}_precision=#{overload_prec}"
                    end
                else
                    if config.exceptions.has_key?(@uid) then
                        # status overridden by current config
                        flag = config.exceptions[@uid]
                        if config.exceptions[@uid] == $STATUS_RPREC then
                            prec_line = "#{type}_#{@id}_precision=#{config.precisions[@uid]}"
                        end
                    else
                        # no override; output configuration default
                        flag = config.default
                    end
                end
            end
            if $mixed_use_rprec then
                if flag == $STATUS_SINGLE then
                    flag = $STATUS_RPREC
                    prec_line = "#{type}_#{@id}_precision=#{$rprec_split_threshold}"
                elsif flag == $STATUS_DOUBLE then
                    flag = $STATUS_RPREC
                    prec_line = "#{type}_#{@id}_precision=52"
                end
            end
            fout.print(flag)
        else
            if overload.nil? then
                if config.exceptions.has_key?(@uid) then
                    # children status overridden by current config
                    overload = config.exceptions[@uid]
                    if overload == $STATUS_RPREC then
                        overload_prec = config.precisions[@uid]
                    end
                elsif not @orig_status == $STATUS_NONE then
                    # children status overridden by original config
                    overload = @orig_status
                end
            end
            fout.print(" ")
        end
        fout.print(" ")
        fout.print($TYPE_SPACES[@type])     # indentation
        fout.print(@uid)
        if @attrs.has_key?("desc") then
            fout.print(" \"")
            fout.print(@attrs["desc"])
            fout.print("\"")
        end
        fout.print("\n")
        if not prec_line.nil? then
            fout.puts prec_line
        end
        @children.each do |pt|
            pt.output(config, fout, overload, overload_prec)
        end
    end

    def output_typeforge (config, fout, overload=nil, func_name="")
        if @type == $TYPE_VARIABLE then
            flag = @orig_status
            if flag == $STATUS_CANDIDATE then
                if not overload.nil? then
                    flag = overload
                elsif config.exceptions.has_key?(@uid) then
                    flag = config.exceptions[@uid]
                end
                if flag == $STATUS_SINGLE then
                    fout.puts "replace_vartype;#{func_name};#{@attrs["desc"]};float"
                end
            end
        else
            if config.exceptions.has_key?(@uid) then
                overload = config.exceptions[@uid]
            end
            if @type == $TYPE_FUNCTION then
                func_name = @attrs["desc"]
            end
            @children.each do |c|
                c.output_typeforge(config, fout, overload, func_name)
            end
        end
    end

    def output_json (config, actions, overload=nil)
        if @type == $TYPE_VARIABLE then
            flag = @orig_status
            if flag == $STATUS_CANDIDATE then
                if not overload.nil? then
                    flag = overload
                elsif config.exceptions.has_key?(@uid) then
                    flag = config.exceptions[@uid]
                end
                if flag == $STATUS_SINGLE then
                    a = Hash.new
                    a["uid"] = @id.to_s
                    a["action"] = "replace_varbasetype"
                    a["handle"] = @attrs["addr"]
                    a["name"] = @attrs["desc"]
                    a["to_type"] = "float"
                    actions << a
                end
            end
        else
            if config.exceptions.has_key?(@uid) then
                overload = config.exceptions[@uid]
            end
            @children.each do |c|
                c.output_json(config, actions, overload)
            end
        end
    end
end # }}}

# AppConfig
#
# Represents a particular replacement configuration. To save space, an
# exception-based scheme is used; it keeps a "default" replacement status for
# all instructions that are not covered by an exception. Any exceptions at a
# level higher than an instruction (module, function, etc.) propogate to
# lower levels.
#
# {{{ AppConfig
class AppConfig
    attr_accessor :cuid             # unique identifier (string)
    attr_accessor :label            # human-readable description; e.g. "MODULE #1: boxes.c; MODULE #2: spheres.c"
    attr_accessor :default          # status
    attr_accessor :exceptions       # cuid -> status
    attr_accessor :attrs            # string => string

    attr_accessor :defprec          # default precision (int)
    attr_accessor :precisions       # cuid -> int

    def initialize (cuid, label, default)
        @cuid = cuid
        @label = label
        @default = default
        @exceptions = Hash.new
        @attrs = Hash.new
        @defprec = 52
        @precisions = Hash.new
    end

    def <=> (c2)
        result = nil

        # ascending level rank -> descending executed %
        if @attrs.has_key?("level") and c2.attrs.has_key?("level") then
            l1 = @attrs["level"]
            l2 = c2.attrs["level"]
            if l1 == l2 then
                if @attrs.has_key?("pct_cinst") and c2.attrs.has_key?("pct_cinst") then
                    oc1 = @attrs["pct_cinst"].to_f
                    oc2 = c2.attrs["pct_cinst"].to_f
                    if oc1 == oc2 then
                        result = -1
                    else
                        result = oc2 <=> oc1
                    end
                else
                    result = -1
                end
            else
                result = $TYPE_RANK[l1] <=> $TYPE_RANK[l2]
            end
        else
            result = -1
        end

        # descending instrumented % + executed %
        if @attrs.has_key?("pct_icount") and c2.attrs.has_key?("pct_icount") and
           @attrs.has_key?("pct_cinst") and c2.attrs.has_key?("pct_cinst") then
            oi1 = @attrs["pct_icount"].to_f
            oi2 = c2.attrs["pct_icount"].to_f
            oc1 = @attrs["pct_cinst"].to_f
            oc2 = c2.attrs["pct_cinst"].to_f
            result = (oi2+oc2) <=> (oi1+oc1)
        end

        return result
    end

    def filename
        # add sanitized cuid for uniqueness
        fn = "#{$search_tag}_"
        @cuid.each_char do |c|
            if c =~ /[0-9a-zA-Z_]/ then
                fn << c.downcase
            elsif c == ' ' then
                fn << "_"
            end
        end
        # add sanitized description for readability (in some cases)
        if @attrs.has_key?("desc") and (@cuid.include?($TYPE_MODULE) or @cuid.include?($TYPE_FUNCTION)) then
            @attrs["desc"].each_char do |c|
                if c =~ /[0-9a-zA-Z_]/ then
                    fn << c.downcase
                elsif c == ' ' then
                    fn << "_"
                end
            end
        end
        fn << ".cfg"
        return fn
    end

    def add_pt_info(pt)
        if pt.attrs.has_key?("cinst") then
            @attrs["cinst"] = pt.attrs["cinst"]
        else
            @attrs["cinst"] = 0
        end
    end

end # }}}

# Search strategy routines
require_relative 'craft_strategies'

# Search management routines
require_relative 'craft_manage'

# File I/O routines
require_relative 'craft_filemanip'

# Helper routines
require_relative 'craft_helpers'

# App entry point

# {{{ main method
def main
    srand

    # initialize global variables
    $search_tag = "craft"                   # filename tag
    $craft_builder = "craft_builder"        # standard builder program name
    $craft_driver = "craft_driver"          # standard driver program name
    $binary_name = ""                       # prevents crashes if there is no binary (e.g., in variable mode)
    $status_preferred = $STATUS_SINGLE      # preferred replacement status
    $status_alternate = $STATUS_DOUBLE      # replacement status if cannot be preferred
    $status_blank = " "                     # "no result" replacement status
    $fortran_mode = false                   # pass "-N" to mutator
    $variable_mode = false                  # use source-to-source to generate program variants
    $base_type = $TYPE_INSTRUCTION          # stop splitting configs at this level
    $skip_nonexecuted = true                # don't bother running configs with non-executed instructions
    $mixed_use_rprec = false                # use rprec 23-bit truncation to simulate mixed svinp analysis
    $rprec_split_threshold = 23             # config splitting threshold for reduced precision searches
    $rprec_runtime_pct_threshold = 0.0      # config cutoff runtime percentage threshold
    $rprec_skip_app_level = false           # skip the app level for rprec search
    $initial_cfg_fn = ""                    # initial config filename (may be blank)
    $addt_cfg_fns = []                      # additional configuration files (may be empty)
    $prof_log_fn = ""                       # initial profiling log (may be blank)
    $cached_fn = ""                         # cached results from previous run (may be blank)
    $max_queue_length = 0                   # track largest queue size (approximate)
    $main_mode = "start"                    # main status ("start/search", "resume", "status", "clean", "worker", "help")
    $restart_inproc = false                 # resume by restarting all inprocess tests
    $resume_lower = false                   # resume at a lower level
    $num_workers = 1                        # number of worker threads
    $workers = Hash.new                     # worker proc info (pid => dirname)
    $status_buffer = ""                     # buffer for output (keeps multiprocess output clean)
    $strategy_name = "bin_simple"           # desired search strategy
    $self_invoke = File.basename($0)        # used to spawn worker threads
    $fpconf_invoke = "fpconf"               # invoke configuration generator
    $fpconf_options = "-c --svinp double"   # configuration generator options
    $fpinst_invoke = "fpinst"               # invoke mutator
    $cached_configs = Array.new             # cached results from a previous run
    $binary_serialization = true            # use binary serialization (faster) for queues instead of YAML
    $disable_queue_sort = false             # disable workqueue sorting
    $run_final_config = true                # test the final config?
    $num_trials = 1                         # default number of trials

    # check command-line options
    if ARGV.size == 0 or ARGV[0] == "help" or ARGV.include?("-h") then
        $main_mode = "help"
        print_usage
        exit
    end

    parse_command_line
    
    # cleaning mode
    if $main_mode == "clean" then
        puts "Cleaning..."
        clean_everything
        puts "Done."
        exit
    end

    # set up environment and filenames
    if $main_mode != "worker" then
        $search_path = Dir.getwd + "/"

        # this really should happen BEFORE parse_command_line so that the
        # command-line parameters will override the craft_driver options, but
        # the worker threads shouldn't read the craft_driver since the options
        # are saved in the settings files, but we don't know if we're a worker
        # until we parse the command-line options
        read_craft_driver
    end

    # plain text info files
    $settings_fn = "#{$search_path}#{$search_tag}.settings"
    $program_fn = "#{$search_path}#{$search_tag}.program"
    $mainlog_fn = "#{$search_path}#{$search_tag}.mainlog"
    $walltime_fn = "#{$search_path}#{$search_tag}.walltime"

    # files containing lists of AppConfig objects
    $workqueue_fn = "#{$search_path}#{$search_tag}.workqueue"     # waiting to be tested
    $inproc_fn = "#{$search_path}#{$search_tag}.inproc"           # currently running
    $tested_fn = "#{$search_path}#{$search_tag}.tested"           # finished (passed, failed, or aborted)

    # important single configuration files
    $orig_config_fn = "#{$search_path}craft_orig.cfg"
    $final_config_fn = "#{$search_path}craft_final.cfg"

    # configuration file directories
    $perf_path     = "#{$search_path}baseline/"    # baseline performance test
    $prof_path     = "#{$search_path}profile/"     # profiler run
    $final_path    = "#{$search_path}final/"       # single final "best" config (cfg file + mutant)
    $best_path     = "#{$search_path}best/"        # top 10 "best" individual configs (cfg files only)
    $passed_path   = "#{$search_path}passed/"      # all successful configs (cfg files only)
    $failed_path   = "#{$search_path}failed/"      # all failed configs (cfg files only)
    $aborted_path  = "#{$search_path}aborted/"     # all aborted configs (cfg files only)
    $snapshot_path = "#{$search_path}snapshots/"   # status printouts

    if $main_mode == "status" then
        print_status
        exit
    end

    # check for driver script
    if !File.exist?("#{$search_path}#{$craft_driver}") then
        puts "No driver program \"craft_driver\" found."
        puts "Aborting."
        exit
    end

    if $main_mode == "worker" then

        # this is just a worker process
        
        load_settings
        initialize_program
        read_profiler_data
        initialize_strategy
        run_main_search_loop                      # main loop
        #puts "Worker finished.  [Empty queue]"

    else

        # this is a supervisor process

        puts ""
        puts "CRAFT #{$CRAFT_VERSION}"
        puts "Executable:  #{$binary_name}"
        puts "Working dir: #{$search_path}"
        puts ""

        if $main_mode == "start" then
            # this is the first invocation of this analysis; initialize everything
            initialize_search
        else
            # we're resuming an analysis
            if not File.exists?($settings_fn) then
                puts "Cannot resume; no search detected in current folder"
                exit
            end
            puts "Resuming in-process search ..."
            if File.exist?($final_path) then
                # clear out any final configuration testing
                FileUtils.rm_rf($final_path)
            end
            if File.exist?($walltime_fn) then
                # previous search was completed; restart wall timer
                $start_time = Time.now
                FileUtils.rm_rf($walltime_fn)
            end
            load_settings
            initialize_program
            read_profiler_data
            initialize_strategy
            if $restart_inproc then
                toDelete = Array.new
                Dir.glob("*_worker*") do |fn| toDelete << fn end
                toDelete.each do |f| FileUtils.rm_rf(f) end
                move_all_inproc_to_workqueue
            end
            if $resume_lower then
                resume_lower_search
                save_settings
            end
        end

        # set up worker thread folders
        $num_workers.times do |id|
            worker_dir = "#{$search_path + $binary_name}_#{Process.pid}_worker#{id}"
            if File.exist?(worker_dir) then
                FileUtils.rm_rf(worker_dir)
            end
            Dir.mkdir(worker_dir)
            $workers[id] = worker_dir
        end

        # spawn worker threads (don't spawn more than we need right now, though)
        [get_workqueue_length, $num_workers].min.times do |id|
            worker_dir = "#{$search_path + $binary_name}_#{Process.pid}_worker#{id}"
            job = fork do
                exec "cd #{worker_dir} && #{$self_invoke} worker #{id} #{$search_path}"
            end
            $workers.delete(id)
            $workers[job] = worker_dir
            #puts "Spawned worker thread #{id} (pid=#{job})."
        end

        # main loop
        puts "Initialization complete. Starting main search routine with #{get_workqueue_length} configuration(s) in the queue."
        puts ""
        if $strategy.has_custom_supervisor? then
            $strategy.run_custom_supervisor
        else
            run_main_supervisor_loop
        end

        # test final config, assemble results, etc.
        finalize_search

    end
end # }}}

# top-level: call main
main

